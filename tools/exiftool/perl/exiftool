#!/usr/bin/perl -w
#------------------------------------------------------------------------------
# File:         exiftool
#
# Description:  Read/write meta information
#
# Revisions:    Nov. 12/03 - P. Harvey Created
#               (See html/history.html for revision history)
#
# References:   ATV - Alexander Vonk, private communication
#------------------------------------------------------------------------------
use strict;
require 5.004;

my $version = '9.13';

# add our 'lib' directory to the include list BEFORE 'use Image::ExifTool'
my $exeDir;
BEGIN {
    # get exe directory
    $exeDir = ($0 =~ /(.*)[\\\/]/) ? $1 : '.';
    # add lib directory at start of include path
    unshift @INC, "$exeDir/lib";
    # load or disable config file if specified
    if (@ARGV and lc($ARGV[0]) eq '-config') {
        shift;
        $Image::ExifTool::configFile = shift;
    }
}
use Image::ExifTool qw{:Public Open};

# function prototypes
sub SigInt();
sub SigCont();
sub Cleanup();
sub GetImageInfo($$);
sub SetImageInfo($$$);
sub CleanXML($);
sub EncodeXML($);
sub FormatXML($$$);
sub EscapeJSON($;$);
sub FormatJSON($$$);
sub PrintCSV();
sub ConvertBinary($);
sub AddSetTagsFile($;$);
sub DoSetFromFile($$$);
sub CleanFilename($);
sub ProcessFiles($;$);
sub ScanDir($$;$);
sub SetFileTime($@);
sub PreserveTime();
sub LoadPrintFormat($);
sub FilenameSPrintf($;$);
sub NextUnusedFilename($;$);
sub CreateDirectory($);
sub OpenOutputFile($);
sub AcceptFile($);
sub SlurpFile($$);
sub Rename($$);
sub ReadStayOpen($);
sub PrintTagList($@);
sub PrintErrors($$$);

$SIG{INT}  = 'SigInt';  # do cleanup on Ctrl-C
$SIG{CONT} = 'SigCont'; # (allows break-out of delays)
END {
    Cleanup();
}

# declare all static file-scope variables
my @commonArgs;     # arguments common to all commands
my @csvFiles;       # list of files when reading with CSV option
my @csvTags;        # order of tags for first file with CSV option (lower case)
my @delFiles;       # list of files to delete
my @dynamicFiles;   # list of -tagsFromFile files with dynamic names and -TAG<=FMT pairs
my @exclude;        # list of excluded tags
my @files;          # list of files and directories to scan
my @moreArgs;       # more arguments to process after -stay_open -@
my @newValues;      # list of new tag values to set
my @srcFmt;         # source file name format strings
my @tags;           # list of tags to extract
my %csvTags;        # lookup for all found tags with CSV option (lower case keys)
my %database;       # lookup for database information based on file name
my %filterExt;      # lookup for filtered extensions
my %ignore;         # directory names to ignore
my %preserveTime;   # preserved timestamps for files
my %printFmt;       # the contents of the print format file
my %setTags;        # hash of list references for tags to set from files
my %setTagsList;    # list of other tag lists for multiple -tagsFromFile from the same file
my %warnedOnce;     # lookup for once-only warnings
my $allGroup;       # show group name for all tags
my $argFormat;      # use exiftool argument-format output
my $binaryOutput;   # flag for binary output (undef or 1, or 0 for binary XML/PHP)
my $binaryStdout;   # flag set if we output binary to stdout
my $comma;          # flag set if we need a comma in JSON output
my $condition;      # conditional processing of files
my $count;          # count of files scanned
my $countBad;       # count of files with errors
my $countBadCr;     # count files not created due to errors
my $countBadWr;     # count write errors
my $countCopyWr;    # count of files copied without being changed
my $countCreated;   # count output files created
my $countDir;       # count of directories scanned
my $countFailed;    # count files that failed condition
my $countGoodCr;    # count files created OK
my $countGoodWr;    # count files written OK
my $countNewDir;    # count of directories created
my $countSameWr;    # count files written OK but not changed
my $critical;       # flag for critical operations (disable CTRL-C)
my $csv;            # flag for CSV option (set to "CSV", or maybe "JSON" when writing)
my $csvAdd;         # flag to add CSV information to existing lists
my $csvSaveCount;   # save counter for last CSV file loaded
my $deleteOrig;     # 0=restore original files, 1=delete originals, 2=delete w/o asking
my $disableOutput;  # flag to disable normal output
my $doSetFileName;  # flag set if FileName may be written
my $doUnzip;        # flag to extract info from .gz and .bz2 files
my $escapeHTML;     # flag to escape printed values for html
my $evalWarning;    # warning from eval
my $executeID;      # -execute ID number
my $fileHeader;     # header to print to output file (or console, once)
my $fileTrailer;    # trailer for output file
my $filtered;       # flag indicating file was filtered by name
my $filterFlag;     # file filter flag (0x01=deny extensions, 0x02=allow extensions)
my $fixLen;         # flag to fix description lengths when writing alternate languages
my $forcePrint;     # force printing of tags whose values weren't found
my $helped;         # flag to avoid printing help if no tags specified
my $html;           # flag for html-formatted output (2=html dump)
my $interrupted;    # flag set if CTRL-C is pressed during a critical process
my $isWriting;      # flag set if we are writing tags
my $joinLists;      # flag set to join list values into a single string
my $json;           # flag for JSON/PHP output format (1=JSON, 2=PHP)
my $listItem;       # item number for extracting single item from a list
my $listSep;        # list item separator (', ' by default)
my $mainTool;       # main ExifTool object
my $multiFile;      # non-zero if we are scanning multiple files
my $outFormat;      # -1=Canon format, 0=same-line, 1=tag names, 2=values only
my $outOpt;         # output file or directory name
my $overwriteOrig;  # flag to overwrite original file
my $pause;          # pause before returning
my $preserveTime;   # flag to preserve times of updated files
my $progress;       # progress cound
my $progressMax;    # total number of files to process
my $progStr;        # progress message string
my $quiet;          # flag to disable printing of informational messages / warnings
my $recurse;        # recurse into subdirectories
my $rtnVal;         # command return value (0=success)
my $saveCount;      # count the number of times we will/did call SaveNewValues()
my $scanWritable;   # flag to process only writable file types
my $seqFileNum;     # sequential file number used for %C
my $showGroup;      # number of group to show (may be zero or '')
my $showTagID;      # non-zero to show tag ID's
my $stayOpenBuff='';# buffer for -stay_open file
my $stayOpenFile;   # name of the current -stay_open argfile
my $structOpt;      # output structured XMP information (JSON and XML output only)
my $tabFormat;      # non-zero for tab output format
my $textOut;        # extension for text output file (or undef for no output)
my $textOverwrite;  # flag to overwrite existing text output file
my $tmpFile;        # temporary file to delete on exit
my $tmpText;        # temporary text file
my $utf8;           # flag set if we are using UTF-8 encoding
my $validFile;      # flag indicating we processed a valid file
my $verbose;        # verbose setting
my $xml;            # flag for XML-formatted output

# flag to keep the input -@ argfile open:
# 0 = normal behaviour
# 1 = received "-stay_open true" and waiting for argfile to keep open
# 2 = currently reading from STAYOPEN argfile
# 3 = waiting for -@ to switch to a new STAYOPEN argfile
my $stayOpen = 0;

# lookup for O/S names which may use a backslash as a directory separator
# (ref File::Spec of PathTools-3.2701)
my %hasBackslash = ( MSWin32 => 1, os2 => 1, dos => 1, NetWare => 1, symbian => 1, cygwin => 1 );

# lookup for O/S names which use CR/LF newlines
my $isCRLF = { MSWin32 => 1, os2 => 1, dos => 1 }->{$^O};

# lookup for JSON characters that we escape specially
my %jsonChar = ( '"'=>'"', '\\'=>'\\', "\t"=>'t', "\n"=>'n', "\r"=>'r' );

# options requiring additional arguments
# (used only to skip over these arguments when reading -stay_open ARGFILE)
my %optArgs = (
    '-tagsfromfile' => 1, '-addtagsfromfile' => 1, '-alltagsfromfile' => 1,
    '-@' => 1,
    '-c' => 1, '-coordformat' => 1,
    '-charset' => 0, # (optional arg; OK because arg cannot begin with "-")
    '-config' => 1,
    '-d' => 1, '-dateformat' => 1,
    '-D' => 0, # nececessary to avoid matching lower-case equivalent
    '-echo' => 1, '-echo2' => 1,
    '-ext' => 1, '--ext' => 1, '-extension' => 1, '--extension' => 1,
    '-fileorder' => 1,
    '-geotag' => 1,
    '-i' => 1, '-ignore' => 1,
    '-if' => 1,
    '-lang' => 0, # (optional arg; cannot begin with "-")
    '-listitem' => 1,
    '-o' => 1, '-out' => 1,
    '-p' => 1, '-printformat' => 1,
    '-P' => 0,
    '-password' => 1,
    '-require' => 1,
    '-sep' => 1, '-separator' => 1,
    '-srcfile' => 1,
    '-stay_open' => 1,
    '-use' => 1,
    '-w' => 1, '-w!' => 1, '-textout' => 1, '-textout!' => 1,
    '-x' => 1, '-exclude' => 1,
    '-X' => 0,
);

# exit routine
sub Exit {
    if ($pause) {
        if (eval 'require Term::ReadKey') {
            print STDERR "-- press any key --";
            Term::ReadKey::ReadMode('cbreak');
            Term::ReadKey::ReadKey(0);
            Term::ReadKey::ReadMode(0);
            print STDERR "\b \b" x 20;
        } else {
            print STDERR "-- press RETURN --\n";
            <STDIN>;
        }
    }
    exit shift;
}
# my warning and error routines (NEVER say "die"!)
sub Warn  { warn(@_) if $quiet < 2 or $_[0] =~ /^Error/; }
sub Error { Warn @_; $rtnVal = 1; }
sub WarnOnce($) {
    Warn(@_) and $warnedOnce{$_[0]} = 1 unless $warnedOnce{$_[0]};
}

# define signal handlers and cleanup routine
sub SigInt()  {
    $critical and $interrupted = 1, return;
    Cleanup();
    exit 1;
}
sub SigCont() { }
sub Cleanup() {
    unlink $tmpFile if defined $tmpFile;
    unlink $tmpText if defined $tmpText;
    undef $tmpFile;
    undef $tmpText;
    PreserveTime() if %preserveTime;
}

#------------------------------------------------------------------------------
# main script
#

# isolate arguments common to all commands
if (grep /^-common_args$/i, @ARGV) {
    my (@newArgs, $common);
    foreach (@ARGV) {
        if (/^-common_args$/i) {
            $common = 1;
        } elsif ($common) {
            push @commonArgs, $_;
        } else {
            push @newArgs, $_;
        }
    }
    @ARGV = @newArgs if $common;
}

#..............................................................................
# loop over sets of command-line arguments separated by "-execute"
Command: while (@ARGV or not defined $rtnVal or $stayOpen >= 2 or @commonArgs)
{

# attempt to restore text mode for STDOUT if necessary
if ($binaryStdout) {
    binmode(STDOUT,':crlf') if $] >= 5.006 and $isCRLF;
    $binaryStdout = 0;
}

# flush console and print "{ready}" message if -stay_open is in effect
if ($stayOpen >= 2) {
    if ($quiet) {
        # flush output if possible
        eval 'require IO::Handle' and STDERR->flush(), STDOUT->flush();
    } else {
        eval 'require IO::Handle' and STDERR->flush();
        my $id = defined $executeID ? $executeID : '';
        my $save = $|;
        $| = 1;     # turn on output autoflush for stdout
        print "{ready$id}\n";
        $| = $save; # restore original autoflush setting
    }
}

$rtnVal = 0 unless defined $rtnVal;

# initialize necessary static file-scope variables
# (not done: @commonArgs, @moreArgs, $critical, $binaryStdout, $helped,
#  $interrupted, $mainTool, $pause, $rtnVal, $stayOpen, $stayOpenBuff, $stayOpenFile)
undef @csvFiles;
undef @csvTags;
undef @delFiles;
undef @dynamicFiles;
undef @exclude;
undef @files;
undef @newValues;
undef @srcFmt;
undef @tags;
undef %csvTags;
undef %database;
undef %filterExt;
undef %ignore;
undef %printFmt;
undef %preserveTime;
undef %setTags;
undef %setTagsList;
undef %warnedOnce;
undef $allGroup;
undef $argFormat;
undef $binaryOutput;
undef $comma;
undef $condition;
undef $csv;
undef $csvAdd;
undef $deleteOrig;
undef $disableOutput;
undef $doSetFileName;
undef $doUnzip;
undef $escapeHTML;
undef $evalWarning;
undef $executeID;
undef $fileHeader;
undef $fileTrailer;
undef $filtered;
undef $fixLen;
undef $forcePrint;
undef $joinLists;
undef $listItem;
undef $multiFile;
undef $outOpt;
undef $preserveTime;
undef $progress;
undef $progressMax;
undef $recurse;
undef $scanWritable;
undef $showGroup;
undef $showTagID;
undef $structOpt;
undef $textOut;
undef $textOverwrite;
undef $tmpFile;
undef $tmpText;
undef $validFile;
undef $verbose;

$count = 0;
$countBad = 0;
$countBadCr = 0;
$countBadWr = 0;
$countCopyWr = 0;
$countCreated = 0;
$countDir = 0;
$countFailed = 0;
$countGoodCr = 0;
$countGoodWr = 0;
$countNewDir = 0;
$countSameWr = 0;
$csvSaveCount = 0;
$filterFlag = 0;
$html = 0;
$isWriting = 0;
$json = 0;
$listSep = ', ';
$outFormat = 0;
$overwriteOrig = 0;
$progStr = '';
$quiet = 0;
$saveCount = 0;
$seqFileNum = 0;
$tabFormat = 0;
$utf8 = 1;
$xml = 0;

# define local variables used only in this command loop
my @fileOrder;      # tags to use for ordering of input files
my %excludeGrp;     # hash of tags excluded by group
my $addGeotime;     # automatically added geotime argument
my $allInGroup;     # flag to show all tags in a group
my $doGlob;         # flag set to do filename wildcard expansion
my $escapeXML;      # flag to escape printed values for xml
my $setTagsFile;    # filename for last TagsFromFile option
my $sortOpt;        # sort option is used
my $useMWG;         # flag set if we are using any MWG tag

my ($argsLeft, @nextPass);
my $pass = 0;

# for Windows, use globbing for wildcard expansion if available - MK/20061010
if ($^O eq 'MSWin32' and eval 'require File::Glob') {
    # override the core glob forcing case insensitivity
    import File::Glob qw(:globally :nocase);
    $doGlob = 1;
}

$mainTool = new Image::ExifTool;        # create ExifTool object

# don't extract duplicates by default unless set by UserDefined::Options
$mainTool->Options(Duplicates => 0) unless %Image::ExifTool::UserDefined::Options
    and defined $Image::ExifTool::UserDefined::Options{Duplicates};

# parse command-line options in 2 passes...
# pass 1: set all of our ExifTool options
# pass 2: print all of our help and informational output (-list, -ver, etc)
for (;;) {

  # execute the command now if no more arguments or -execute is used
  if (not @ARGV or $ARGV[0] =~ /^-execute(\d*)$/i) {
    if (@ARGV) {
        $executeID = $1;        # save -execute number for "{ready}" response
        $helped = 1;            # don't show help if we used -execute
    } elsif ($stayOpen >= 2) {
        ReadStayOpen(\@ARGV);   # read more arguments from -stay_open file
        next;
    }
    if ($pass == 0) {
        # insert common arguments now if not done already
        if (@commonArgs and not defined $argsLeft) {
            # count the number of arguments remaining for subsequent commands
            $argsLeft = scalar(@ARGV) + scalar(@moreArgs);
            unshift @ARGV, @commonArgs;
            # all done with commonArgs if this is the end of the command
            undef @commonArgs unless $argsLeft;
            next;
        }
        # check if we have more arguments now than we did before we processed
        # the common arguments.  If so, then we have an infinite processing loop
        if (defined $argsLeft and $argsLeft < scalar(@ARGV) + scalar(@moreArgs)) {
            Warn "Ignoring -common_args from $ARGV[0] onwards to avoid infinite recursion\n";
            while ($argsLeft < scalar(@ARGV) + scalar(@moreArgs)) {
                @ARGV and shift(@ARGV), next;
                shift @moreArgs;
            }
        }
        # require MWG module if used in any argument
        # (note: this also covers the -p option because these tags were added to @tags)
        $useMWG = 1 if not $useMWG and grep /^mwg:/i, @tags;
        require Image::ExifTool::MWG if $useMWG;
    }
    if (@nextPass) {
        # process arguments which were deferred to the next pass
        unshift @ARGV, @nextPass;
        undef @nextPass;
        ++$pass;
        next;
    }
    @ARGV and shift;    # remove -execute from argument list
    last;               # process the command now
  }
  $_ = shift;
  if (s/^(-|\xe2\x88\x92)//) {  # allow funny dashes (nroff dash bug for cut-n-paste from pod)
    s/^\xe2\x88\x92/-/;         # translate double-dash too
    my $a = lc $_;
    if (/^list([wfrdx]|wf|g(\d*))?$/i) {
        $pass or push(@nextPass,"-$_");
        my $type = lc($1 || '');
        if (not $type or $type eq 'w' or $type eq 'x') {
            my $group;
            if ($ARGV[0] and $ARGV[0] =~ /^(-|\xe2\x88\x92)(.+):(all|\*)$/i) {
                if ($pass == 0) {
                    $useMWG = 1 if lc($2) eq 'mwg';
                    push(@nextPass, shift);
                    next;
                }
                $group = $2;
                shift;
                $group =~ /IFD/i and Warn("Can't list tags for specific IFD\n"), next;
                $group =~ /^(all|\*)$/ and undef $group;
            } else {
                $pass or next;
            }
            $helped = 1;
            if ($type eq 'x') {
                require Image::ExifTool::TagInfoXML;
                my %opts;
                $opts{Flags} = 1 if $forcePrint;
                $opts{NoDesc} = 1 if $outFormat > 0;
                Image::ExifTool::TagInfoXML::Write(undef, $group, %opts);
                next;
            }
            my $wr = ($type eq 'w');
            my $msg = ($wr ? 'Writable' : 'Available') . ($group ? " $group" : '') . ' tags';
            PrintTagList($msg, $wr ? GetWritableTags($group) : GetAllTags($group));
            # also print shortcuts if listing all tags
            next if $group or $wr;
            my @tagList = GetShortcuts();
            PrintTagList('Command-line shortcuts', @tagList) if @tagList;
            next;
        }
        $pass or next;
        $helped = 1;
        if ($type eq 'wf') {
            my @wf;
            CanWrite($_) and push @wf, $_ foreach GetFileType();
            PrintTagList('Writable file extensions', @wf);
        } elsif ($type eq 'f') {
            PrintTagList('Supported file extensions', GetFileType());
        } elsif ($type eq 'r') {
            PrintTagList('Recognized file extensions', GetFileType(undef, 0));
        } elsif ($type eq 'd') {
            PrintTagList('Deletable groups', GetDeleteGroups());
        } else { # 'g(\d*)'
            # list all groups in specified family
            my $family = $2 || 0;
            PrintTagList("Groups in family $family", GetAllGroups($family));
        }
        next;
    }
    if ($a eq 'ver') {
        $pass or push(@nextPass,'-ver'), next;
        my $libVer = $Image::ExifTool::VERSION;
        my $str = $libVer eq $version ? '' : " [Warning: Library version is $libVer]";
        print("$version$str$Image::ExifTool::RELEASE\n");
        $helped = 1;
        next;
    }
    if (/^(all|add)?tagsfromfile(=.*)?$/i) {
        $setTagsFile = $2 ? substr($2,1) : (@ARGV ? shift : '');
        if ($setTagsFile eq '') {
            Error("File must be specified for -tagsFromFile option\n");
            next Command;
        }
        # create necessary lists, etc for this new -tagsFromFile file
        AddSetTagsFile($setTagsFile, { Replace => ($1 and lc($1) eq 'add') ? 0 : 1 } );
        next;
    }
    if ($a eq '@') {
        my $argFile = shift or Error("Expecting filename for -\@ option\n"), next Command;
        # switch to new ARGFILE if using chained -stay_open options
        if ($stayOpen == 1) {
            # defer remaining arguments until we close this argfile
            @moreArgs = @ARGV;
            undef @ARGV;
        } elsif ($stayOpen == 3) {
            if ($stayOpenFile and $stayOpenFile ne '-' and $argFile eq $stayOpenFile) {
                # don't allow user to switch to the same -stay_open argfile
                # because it will result in endless recursion
                $stayOpen = 2;
                Warn "Ignoring request to switch to the same -stay_open ARGFILE ($argFile)\n";
                next;
            }
            close STAYOPEN;
            $stayOpen = 1;  # switch to this -stay_open file
        }
        my $fp = ($stayOpen == 1 ? \*STAYOPEN : \*ARGFILE);
        unless (Open($fp, $argFile)) {
            unless ($argFile !~ /^\// and Open($fp, "$exeDir/$argFile")) {
                Error "Error opening arg file $argFile\n";
                next Command;
            }
        }
        if ($stayOpen == 1) {
            $stayOpenFile = $argFile;   # remember the name of the file we have open
            $stayOpenBuff = '';         # initialize buffer for reading this file
            $stayOpen = 2;
            $helped = 1;
            ReadStayOpen(\@ARGV);
            next;
        }
        my (@newArgs, $didBOM);
        foreach (<ARGFILE>) {
            # filter Byte Order Mark if it exists from start of UTF-8 text file
            unless ($didBOM) {
                s/^\xef\xbb\xbf//;
                $didBOM = 1;
            }
            s/^\s+//; s/[\x0d\x0a]+$//s; # remove leading white space and trailing newline
            # remove white space before, and single space after '=', '+=', '-=' or '<='
            s/^(-[-:\w]+#?)\s*([-+<]?=) ?/$1$2/;
            push @newArgs, $_ unless $_ eq '' or /^#/;
        }
        close ARGFILE;
        unshift @ARGV, @newArgs;
        next;
    }
    /^(-?)(a|duplicates)$/i and $mainTool->Options(Duplicates => ($1 ? 0 : 1)), next;
    /^arg(s|format)$/i and $argFormat = 1, next;
    /^b(inary)?$/i and $mainTool->Options(Binary => 1), $binaryOutput = 1, next;
    if (/^c(oordFormat)?$/i) {
        my $fmt = shift;
        $fmt or Error("Expecting coordinate format for -c option\n"), next Command;
        $mainTool->Options('CoordFormat', $fmt);
        next;
    }
    if ($a eq 'charset') {
        my $charset = (@ARGV and $ARGV[0] !~ /^(-|\xe2\x88\x92)/) ? shift : undef;
        if (not $charset) {
            $pass or push(@nextPass, '-charset'), next;
            my %charsets;
            $charsets{$_} = 1 foreach values %Image::ExifTool::charsetName;
            PrintTagList('Available character sets', sort keys %charsets);
            $helped = 1;
        } elsif ($charset !~ s/^(\w+)=// or lc($1) eq 'exiftool') {
            $mainTool->Options(Charset => $charset);
            $utf8 = ($mainTool->Options('Charset') eq 'UTF8');
        } else {
            # set internal encoding of specified metadata type
            my $type = { id3 => 'ID3', iptc => 'IPTC', exif => 'EXIF',
                         photoshop => 'Photoshop', quicktime => 'QuickTime' }->{lc $1};
            $type or Warn("Unknown type for -charset option: $1\n"), next;
            $mainTool->Options("Charset$type" => $charset);
        }
        next;
    }
    /^config$/i and Warn("Ignored -config option (not first on command line)\n"), shift, next;
    if (/^csv(\+?=.*)?/i) {
        my $csvFile = $1;
        # must process on 2nd pass so -f option is available
        unless ($pass) {
            push(@nextPass,"-$_");
            if ($csvFile) {
                push @newValues, { SaveCount => ++$saveCount }; # marker to save new values now
                $csvSaveCount = $saveCount;
            }
            next;
        }
        if ($csvFile) {
            $csvFile =~ s/^(\+?=)//;
            $csvAdd = 2 if $1 eq '+=';
            $verbose and print "Reading CSV file $csvFile\n";
            require Image::ExifTool::Import;
            my $msg = Image::ExifTool::Import::ReadCSV($csvFile, \%database, $forcePrint);
            $msg and Warn("$msg\n");
            $isWriting = 1;
        }
        $csv = 'CSV';
        next;
    }
    if (/^d$/ or $a eq 'dateformat') {
        my $fmt = shift;
        $fmt or Error("Expecting date format for -d option\n"), next Command;
        $mainTool->Options('DateFormat', $fmt);
        next;
    }
    (/^D$/ or $a eq 'decimal') and $showTagID = 'D', next;
    /^delete_original(!?)$/i and $deleteOrig = ($1 ? 2 : 1), next;
    (/^e$/ or $a eq '-composite') and $mainTool->Options(Composite => 0), next;
    (/^-e$/ or $a eq 'composite') and $mainTool->Options(Composite => 1), next;
    (/^E$/ or $a eq 'escapehtml') and require Image::ExifTool::HTML and $escapeHTML = 1, next;
    ($a eq 'ex' or $a eq 'escapexml') and $escapeXML = 1, next;
    if (/^echo(2)?$/i) {
        next unless @ARGV;
        $pass or push(@nextPass, "-$_", shift), next;
        print {$1 ? \*STDERR : \*STDOUT} shift, "\n";
        $helped = 1;
        next;
    }
    if (/^(ee|extractembedded)$/i) {
        $mainTool->Options(ExtractEmbedded => 1);
        $mainTool->Options(Duplicates => 1);
        next;
    }
    # (-execute handled at top of loop)
    if (/^-?ext(ension)?$/i) {
        my $ext = shift;
        defined $ext or Error("Expecting extension for -ext option\n"), next Command;
        $ext =~ s/^\.//;    # remove leading '.' if it exists
        my $flag = /^-/ ? 0 : 1;
        $filterFlag |= (0x01 << $flag);
        $filterExt{uc($ext)} = $flag;
        next;
    }
    if (/^f$/ or $a eq 'forceprint') {
        $forcePrint = 1;
        $mainTool->Options(MissingTagValue => '-');
        next;
    }
    if (/^F([-+]?\d*)$/ or /^fixbase([-+]?\d*)$/i) {
        $mainTool->Options(FixBase => $1);
        next;
    }
    if (/^fast(\d*)$/i) {
        $mainTool->Options(FastScan => (length $1 ? $1 : 1));
        next;
    }
    if ($a eq 'fileorder') {
        push @fileOrder, shift if @ARGV;
        next;
    }
    $a eq 'globaltimeshift' and $mainTool->Options(GlobalTimeShift => shift), next;
    if (/^(g)(roupHeadings|roupNames)?([\d:]*)$/i) {
        $showGroup = $3 || 0;
        $allGroup = ($2 ? lc($2) eq 'roupnames' : $1 eq 'G');
        $mainTool->Options(SavePath => 1) if $showGroup =~ /\b5\b/;
        next;
    }
    if ($a eq 'geotag') {
        my $trkfile = shift;
        $trkfile or Error("Expecting file name for -geotag option\n"), next Command;
        # allow wildcards in filename
        if ($trkfile =~ /[*?]/) {
            # CORE::glob() splits on white space, so use File::Glob if possible
            my @trks = eval('require File::Glob') ? File::Glob::bsd_glob($trkfile) : glob($trkfile);
            @trks or Error("No matching file found for -geotag option\n"), next Command;
            push @newValues, 'geotag='.shift(@trks) while @trks > 1;
            $trkfile = pop(@trks);
        }
        $_ = "geotag=$trkfile";
        # (fall through!)
    }
    if (/^h$/ or $a eq 'htmlformat') {
        require Image::ExifTool::HTML;
        $html = $escapeHTML = 1;
        $json = $xml = 0;
        next;
    }
    (/^H$/ or $a eq 'hex') and $showTagID = 'H', next;
    if (/^htmldump([-+]?\d+)?$/i) {
        $verbose = ($verbose || 0) + 1;
        $html = 2;
        $mainTool->Options(HtmlDumpBase => $1) if defined $1;
        next;
    }
    if (/^i(gnore)?$/i) {
        my $dir = shift;
        defined $dir or Error("Expecting directory name for -i option\n"), next Command;
        $ignore{$dir} = 1;
        next;
    }
    if ($a eq 'if') {
        my $cond = shift;
        defined $cond or Error("Expecting expression for -if option\n"), next Command;
        $useMWG = 1 if $cond =~ /\$\{?mwg:/i;
        if (defined $condition) {
            $condition .= " and ($cond)";
        } else {
            $condition = "($cond)";
        }
        next;
    }
    if (/^j(son)?(\+?=.*)?$/i) {
        if ($2) {
            # must process on 2nd pass because we need -f and -charset options
            unless ($pass) {
                push(@nextPass,"-$_");
                push @newValues, { SaveCount => ++$saveCount }; # marker to save new values now
                $csvSaveCount = $saveCount;
                next;
            }
            my $jsonFile = $2;
            $jsonFile =~ s/^(\+?=)//;
            $csvAdd = 2 if $1 eq '+=';
            $verbose and print "Reading JSON file $jsonFile\n";
            my $chset = $mainTool->Options('Charset');
            require Image::ExifTool::Import;
            my $msg = Image::ExifTool::Import::ReadJSON($jsonFile, \%database, $forcePrint, $chset);
            $msg and Warn("$msg\n");
            $isWriting = 1;
            $csv = 'JSON';
        } else {
            $json = 1;
            $html = $xml = 0;
            $mainTool->Options(Duplicates => 1);
            require Image::ExifTool::XMP;   # for FixUTF8()
        }
        next;
    }
    /^(k|pause)$/i and $pause = 1, next;
    (/^l$/ or $a eq 'long') and --$outFormat, next;
    (/^L$/ or $a eq 'latin') and $utf8 = 0, $mainTool->Options(Charset => 'Latin'), next;
    if ($a eq 'lang') {
        my $lang = (@ARGV and $ARGV[0] !~ /^-/) ? shift : undef;
        if ($lang) {
            # make lower case and use underline as a separator (ie. 'en_ca')
            $lang =~ tr/-A-Z/_a-z/;
            $mainTool->Options(Lang => $lang);
            next if $lang eq $mainTool->Options('Lang');
        } else {
            $pass or push(@nextPass, '-lang'), next;
        }
        my $langs = "Available languages:\n";
        $langs .= "  $_ - $Image::ExifTool::langName{$_}\n" foreach @Image::ExifTool::langs;
        $langs =~ tr/_/-/;  # display dashes instead of underlines in language codes
        $langs = $mainTool->Decode($langs, 'UTF8');
        $langs = Image::ExifTool::HTML::EscapeHTML($langs) if $escapeHTML;
        $lang and Error("Invalid or unsupported language '$lang'.\n$langs"), next Command;
        print $langs;
        $helped = 1;
        next;
    }
    if ($a eq 'listitem') {
        $listItem = shift;
        defined $listItem or Warn("Expecting index for -listItem option\n");
        next;
    }
    /^(m|ignoreminorerrors)$/i and $mainTool->Options(IgnoreMinorErrors => 1), next;
    /^(n|-printconv)$/i and $mainTool->Options(PrintConv => 0), next;
    /^(-n|printconv)$/i and $mainTool->Options(PrintConv => 1), next;
    if (/^o(ut)?$/i) {
        $outOpt = shift;
        defined $outOpt or Error("Expected output file or directory name for -o option\n"), next Command;
        CleanFilename($outOpt);
        next;
    }
    /^overwrite_original$/i and $overwriteOrig = 1, next;
    /^overwrite_original_in_place$/i and $overwriteOrig = 2, next;
    (/^p$/ or $a eq 'printformat') and LoadPrintFormat(shift), next;
    (/^P$/ or $a eq 'preserve') and $preserveTime = 1, next;
    /^password$/i and $mainTool->Options(Password => shift), next;
    if ($a eq 'progress') {
        $progress = 0;
        $verbose = 0 unless defined $verbose;
        next;
    }
    /^q(uiet)?$/i and ++$quiet, next;
    /^r(ecurse)?$/i and $recurse = 1, next;
    if ($a eq 'require') { # undocumented, added in version 8.65
        my $ver = shift;
        unless (defined $ver and Image::ExifTool::IsFloat($ver)) {
            Error("Expecting version number for -require option\n");
            next Command;
        }
        unless ($Image::ExifTool::VERSION >= $ver) {
            Error("Requires ExifTool version $ver or later\n");
            next Command;
        }
        next;
    }
    /^restore_original$/i and $deleteOrig = 0, next;
    (/^S$/ or $a eq 'veryshort') and $outFormat+=2, next;
    /^s(hort)?(\d*)$/i and $outFormat = $2 eq '' ? $outFormat + 1 : $2, next;
    /^scanforxmp$/i and $mainTool->Options(ScanForXMP => 1), next;
    if (/^sep(arator)?$/i) {
        $listSep = shift;
        defined $listSep or Error("Expecting list item separator for -sep option\n"), next Command;
        $mainTool->Options(ListSep => $listSep);
        $joinLists = 1;
        # also split when writing values
        my $listSplit = quotemeta $listSep;
        # a space in the string matches zero or more whitespace characters
        $listSplit =~ s/(\\ )+/\\s\*/g;
        # but a single space alone matches one or more whitespace characters
        $listSplit = '\\s+' if $listSplit eq '\\s*';
        $mainTool->Options(ListSplit => $listSplit);
        next;
    }
    /^sort$/i and $sortOpt = 1, next;
    if ($a eq 'srcfile') {
        @ARGV or Warn("Expecting FMT for -srcfile option\n"), next;
        push @srcFmt, shift;
        next;
    }
    if ($a eq 'stay_open') {
        my $arg = shift;
        defined $arg or Warn("Expecting argument for -stay_open option\n"), next;
        if ($arg =~ /^(1|true)$/i) {
            if (not $stayOpen) {
                $stayOpen = 1;
            } elsif ($stayOpen == 2) {
                $stayOpen = 3;  # chained -stay_open options
            } else {
                Warn "-stay_open already active\n";
            }
        } elsif ($arg =~ /^(0|false)$/i) {
            if ($stayOpen >= 2) {
                # close -stay_open argfile and process arguments up to this point
                close STAYOPEN;
                push @ARGV, @moreArgs;
                undef @moreArgs;
            } elsif (not $stayOpen) {
                Warn("-stay_open wasn't active\n");
            }
            $stayOpen = 0;
        } else {
            Warn "Invalid argument for -stay_open\n";
        }
        next;
    }
    if (/^(-)?struct$/i) {
        $structOpt = $1 ? 0 : 1;
        $mainTool->Options(Struct => $structOpt);
        # require XMPStruct in case we need to serialize a structure
        require 'Image/ExifTool/XMPStruct.pl' if $structOpt;
        next;
    }
    /^t(ab)?$/  and $tabFormat = 1, next;
    if (/^T$/ or $a eq 'table') {
        $tabFormat = 1; $outFormat+=2; ++$quiet; $forcePrint = 1;
        $mainTool->Options(MissingTagValue => '-');
        next;
    }
    if (/^(u)(nknown(2)?)?$/i) {
        my $inc = ($3 or (not $2 and $1 eq 'U')) ? 2 : 1;
        $mainTool->Options(Unknown => $mainTool->Options('Unknown') + $inc);
        next;
    }
    if ($a eq 'use') {
        my $module = shift;
        $module or Error("Expecting module name for -use option\n"), next Command;
        lc $module eq 'mwg' and $useMWG = 1, next;
        local $SIG{'__WARN__'} = sub { $evalWarning = $_[0] };
        unless (eval "require Image::ExifTool::$module" or
                eval "require $module" or
                eval "require '$module'")
        {
            delete $SIG{'__WARN__'};
            Error("Error using module $module\n");
            next Command;
        }
        next;
    }
    if (/^v(erbose)?(\d*)$/i) {
        $verbose = ($2 eq '') ? ($verbose || 0) + 1 : $2;
        next;
    }
    if (/^(w|textout)(!?)$/i) {
        $textOut = shift || Warn("Expecting output extension for -$_ option\n");
        $textOverwrite = $2;
        next;
    }
    if (/^x$/ or $a eq 'exclude') {
        my $tag = shift;
        defined $tag or Error("Expecting tag name for -x option\n"), next Command;
        $tag =~ s/\ball\b/\*/ig;    # replace 'all' with '*' in tag names
        if ($setTagsFile) {
            push @{$setTags{$setTagsFile}}, "-$tag";
        } else {
            push @exclude, $tag;
        }
        next;
    }
    (/^X$/ or $a eq 'xmlformat') and $xml = 1, $html = $json = 0, $mainTool->Options(Duplicates => 1), next;
    if (/^php$/i) {
        $json = 2;
        $html = $xml = 0;
        $mainTool->Options(Duplicates=>1);
        next;
    }
    /^z(ip)?$/i and $doUnzip = 1, $mainTool->Options(Compress => 1, Compact => 1), next;
    $_ eq '' and push(@files, '-'), next;   # read STDIN
    length $_ eq 1 and $_ ne '*' and Error("Unknown option -$_\n"), next Command;
    if (/^[^<]+(<?)=(.*)/s) {
        my $val = $2;
        if ($1 and length($val) and ($val eq '@' or not defined FilenameSPrintf($val))) {
            # save count of new values before a dynamic value
            push @newValues, { SaveCount => ++$saveCount };
        }
        push @newValues, $_;
        if (/^mwg:/i) {
            $useMWG = 1;
        } elsif (/^([-\w]+:)*(filename|directory)\b/i) {
            $doSetFileName = 1;
        } elsif (/^([-\w]+:)*(geotag|geotime)\b/i) {
            if (lc $2 eq 'geotag') {
                if ((not defined $addGeotime or $addGeotime) and length $val) {
                    $addGeotime = ($1 || '') . 'Geotime<DateTimeOriginal';
                }
            } else {
                $addGeotime = '';
            }
        }
    } else {
        # assume '-tagsFromFile @' if tags are being redirected
        # and -tagsFromFile hasn't already been specified
        AddSetTagsFile($setTagsFile = '@') if not $setTagsFile and /(<|>)/;
        if ($setTagsFile) {
            push @{$setTags{$setTagsFile}}, $_;
            if (/>/) {
                $useMWG = 1 if /^(.*>\s*)?mwg:/si;
                if (/\b(filename|directory)#?$/i) {
                    $doSetFileName = 1;
                } elsif (/\bgeotime#?$/i) {
                    $addGeotime = '';
                }
            } else {
                $useMWG = 1 if /^([^<]+<\s*(.*\$\{?)?)?mwg:/si;
                if (/^([-\w]+:)*(filename|directory)\b/i) {
                    $doSetFileName = 1;
                } elsif (/^([-\w]+:)*geotime\b/i) {
                    $addGeotime = '';
                }
            }
        } elsif (/^-(.*)/) {
            push @exclude, $1;
        } else {
            push @tags, $_;
        }
    }
  } elsif ($doGlob and /[*?]/) {
    # glob each filespec if necessary - MK/20061010
    push @files, File::Glob::bsd_glob($_);
    $doGlob = 2;
  } else {
    push @files, $_;
  }
}

# change default EXIF string encoding if MWG used
if ($useMWG and not defined $mainTool->Options('CharsetEXIF')) {
    $mainTool->Options(CharsetEXIF => 'UTF8');
}

# print help
unless ((@tags and not $outOpt) or @files or @newValues) {
    if ($doGlob and $doGlob == 2) {
        Warn "No matching files\n";
        $rtnVal = 1;
        next;
    }
    if ($outOpt) {
        Warn "Nothing to write\n";
        $rtnVal = 1;
        next;
    }
    unless ($helped) {
        # catch warnings if we have problems running perldoc
        local $SIG{'__WARN__'} = sub { $evalWarning = $_[0] };
        my $dummy = \*SAVEERR;  # avoid "used only once" warning
        unless ($^O eq 'os2') {
            open SAVEERR, ">&STDERR";
            open STDERR, '>/dev/null';
        }
        if (system('perldoc',$0)) {
            print "Syntax:  exiftool [OPTIONS] FILE\n\n";
            print "Consult the exiftool documentation for a full list of options.\n";
        }
        unless ($^O eq 'os2') {
            close STDERR;
            open STDERR, '>&SAVEERR';
        }
    }
    next;
}

# do sanity check on -delete_original and -restore_original
if (defined $deleteOrig and (@newValues or @tags)) {
    if (not @newValues) {
        my $verb = $deleteOrig ? 'deleting' : 'restoring from';
        Warn "Can't specify tags when $verb originals\n";
    } elsif ($deleteOrig) {
        Warn "Can't use -delete_original when writing.\n";
        Warn "Maybe you meant -overwrite_original ?\n";
    } else {
        Warn "It makes no sense to use -restore_original when writing\n";
    }
    $rtnVal = 1;
    next;
}

if ($overwriteOrig > 1 and $outOpt) {
    Warn "Can't overwrite in place when -o option is used\n";
    $rtnVal = 1;
    next;
}

if ($escapeHTML or $json) {
    # must be UTF8 for HTML conversion and JSON output
    $mainTool->Options(Charset => 'UTF8');
    # use Escape option to do our HTML escaping unless XML output
    $mainTool->Options(Escape => 'HTML') if $escapeHTML and not $xml;
} elsif ($escapeXML and not $xml) {
    $mainTool->Options(Escape => 'XML');
}

# set sort option
if ($sortOpt) {
    # (note that -csv sorts alphabetically by default anyway if more than 1 file)
    my $sort = ($outFormat > 0 or $xml or $json or $csv) ? 'Tag' : 'Descr';
    $mainTool->Options(Sort => $sort, Sort2 => $sort);
}

# set up for RDF/XML, JSON and PHP output formats
if ($xml) {
    require Image::ExifTool::XMP;   # for EscapeXML()
    my $charset = $mainTool->Options('Charset');
    # standard XML encoding names for supported Charset settings
    # (ref http://www.iana.org/assignments/character-sets)
    my %encoding = (
        UTF8     => 'UTF-8',
        Latin    => 'windows-1252',
        Latin2   => 'windows-1250',
        Cyrillic => 'windows-1251',
        Greek    => 'windows-1253',
        Turkish  => 'windows-1254',
        Hebrew   => 'windows-1255',
        Arabic   => 'windows-1256',
        Baltic   => 'windows-1257',
        Vietnam  => 'windows-1258',
        MacRoman => 'macintosh',
    );
    # switch to UTF-8 if we don't have a standard encoding name
    unless ($encoding{$charset}) {
        $charset = 'UTF8';
        $mainTool->Options(Charset => $charset);
    }
    # set file header/trailer for XML output
    $fileHeader = "<?xml version='1.0' encoding='$encoding{$charset}'?>\n" .
                  "<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\n";
    $fileTrailer = "</rdf:RDF>\n";
    # extract as a list unless short output format
    $joinLists = 1 if $outFormat > 0;
    $mainTool->Options(List => 1) unless $joinLists;
    $showGroup = $allGroup = 1;         # always show group 1
    # set binaryOutput flag to 0 or undef (0 = output encoded binary in XML)
    $binaryOutput = ($outFormat > 0 ? undef : 0) if $binaryOutput;
    $showTagID = 'D' if $tabFormat and not $showTagID;
} elsif ($json) {
    if ($json == 1) { # JSON
        $fileHeader = '[';
        $fileTrailer = "]\n";
        undef $binaryOutput; # can't currently use -b with -json
    } else { # PHP
        $fileHeader = 'Array(';
        $fileTrailer = ");\n";
        # allow binary output in a text-mode file when -php and -b used together
        # (this works because PHP strings are simple arrays of bytes, and CR/LF
        #  won't be messed up in the text mode output because they are converted
        #  to escape sequences in the strings)
        $binaryOutput = 0 if $binaryOutput;
    }
    $mainTool->Options(List => 1) unless $joinLists;
    $mainTool->Options(Duplicates => 0) unless defined $showGroup;
} elsif ($structOpt) {
    $mainTool->Options(List => 1);
} else {
    $joinLists = 1;     # join lists for all other unstructured output formats
}

if ($argFormat) {
    $outFormat = 3;
    $allGroup = 1 if defined $showGroup;
}

# change to forward slashes if necessary in all filenames (like CleanFilename)
if ($hasBackslash{$^O}) {
    tr/\\/\// foreach @files;
}

# can't do anything if no file specified
unless (@files) {
    unless ($outOpt) {
        Warn "No file specified\n";
        $rtnVal = 1;
        next;
    }
    push @files, '';    # create file from nothing
}

# set Verbose and HtmlDump options
if ($verbose) {
    $disableOutput = 1 unless @tags or @exclude;
    undef $binaryOutput;    # disable conflicting option
    if ($html) {
        $html = 2;    # flag for html dump
        $mainTool->Options(HtmlDump => $verbose);
    } else {
        $mainTool->Options(Verbose => $verbose);
    }
} elsif (defined $verbose) {
    # auto-flush output when -v0 is used
    require FileHandle;
    STDOUT->autoflush(1);
    STDERR->autoflush(1);
}

# validate all tags we're writing
my $needSave = 1;
if (@newValues) {
    # assume -geotime value if -geotag specified without -geotime
    if ($addGeotime) {
        AddSetTagsFile($setTagsFile = '@') unless $setTagsFile and $setTagsFile eq '@';
        push @{$setTags{$setTagsFile}}, $addGeotime;
        $verbose and print qq{Argument "-$addGeotime" is assumed\n};
    }
    my %setTagsIndex;
    # add/delete option lookup
    my %addDelOpt = ( '+' => 'AddValue', '-' => 'DelValue', "\xe2\x88\x92" => 'DelValue' );
    $saveCount = 0;
    foreach (@newValues) {
        if (ref $_ eq 'HASH') {
            # save new values now if we stored a "SaveCount" marker
            if ($$_{SaveCount}) {
                $saveCount = $mainTool->SaveNewValues();
                $needSave = 0;
                # insert marker to load values from CSV file now if this was the CSV file
                push @dynamicFiles, \$csv if $$_{SaveCount} == $csvSaveCount;
            }
            next;
        }
        /(.*?)=(.*)/s or next;
        my ($tag, $newVal) = ($1, $2);
        $tag =~ s/\ball\b/\*/ig;    # replace 'all' with '*' in tag names
        $newVal eq '' and undef $newVal;    # undefined to delete tag
        if ($tag =~ /^(All)?TagsFromFile$/i) {
            defined $newVal or Error("Need file name for -tagsFromFile\n"), next Command;
            ++$isWriting;
            if ($newVal eq '@' or not defined FilenameSPrintf($newVal)) {
                push @dynamicFiles, $newVal;
                next;   # set tags from dynamic file later
            }
            unless (-e $newVal) {
                Warn "File '$newVal' does not exist for -tagsFromFile option\n";
                $rtnVal = 1;
                next Command;
            }
            my $setTags = $setTags{$newVal};
            # do we have multiple -tagsFromFile options with this file?
            if ($setTagsList{$newVal}) {
                # use the tags set in the i-th occurrence
                my $i = $setTagsIndex{$newVal} || 0;
                $setTagsIndex{$newVal} = $i + 1;
                $setTags = $setTagsList{$newVal}[$i] if $setTagsList{$newVal}[$i];
            }
            # set specified tags from this file
            unless (DoSetFromFile($mainTool, $newVal, $setTags)) {
                $rtnVal = 1;
                next Command;
            }
            $needSave = 1;
            next;
        }
        my %opts = (
            Protected => 1, # allow writing of 'unsafe' tags
            Shift => 0,     # shift values if possible instead of adding/deleting
        );
        if ($tag =~ s/<// and defined $newVal) {
            if (defined FilenameSPrintf($newVal)) {
                SlurpFile($newVal, \$newVal) or next;
            } else {
                $tag =~ s/([-+]|\xe2\x88\x92)$// and $opts{$addDelOpt{$1}} = 1;
                # verify that this tag can be written
                my $result = Image::ExifTool::IsWritable($tag);
                if ($result) {
                    $opts{ProtectSaved} = $saveCount;   # protect new values set after this
                    # add to list of dynamic tag values
                    push @dynamicFiles, [ $tag, $newVal, \%opts ];
                    ++$isWriting;
                } elsif (defined $result) {
                    Warn "Tag '$tag' is not writable\n";
                } else {
                    Warn "Tag '$tag' does not exist\n";
                }
                next;
            }
        }
        if ($tag =~ s/([-+]|\xe2\x88\x92)$//) {
            $opts{$addDelOpt{$1}} = 1;  # set AddValue or DelValue option
            # set $newVal to '' if deleting nothing
            $newVal = '' if $1 eq '-' and not defined $newVal;
        }
        my ($rtn, $wrn) = $mainTool->SetNewValue($tag, $newVal, %opts);
        $needSave = 1;
        ++$isWriting if $rtn;
        $wrn and Warn "Warning: $wrn\n";
    }
    # exclude specified tags
    foreach (@exclude) {
        $mainTool->SetNewValue($_, undef, Replace => 2);
        $needSave = 1;
    }
    unless ($isWriting or $outOpt or @tags) {
        Warn "Nothing to do.\n";
        $rtnVal = 1;
        next;
    }
} elsif (grep /^(\*:)?\*$/, @exclude) {
    Warn "All tags excluded -- nothing to do.\n";
    $rtnVal = 1;
    next;
}
if ($isWriting and @tags and not $outOpt) {
    my ($tg, $s) = @tags > 1 ? ("$tags[0] ...", 's') : ($tags[0], '');
    Warn "Ignored superfluous tag name$s or invalid option$s: -$tg\n";
}
# save current state of new values if setting values from target file
# or if we may be translating to a different format
$mainTool->SaveNewValues() if $outOpt or (@dynamicFiles and $needSave);

$multiFile = 1 if @files > 1;
@exclude and $mainTool->Options(Exclude => \@exclude);

undef $binaryOutput if $html;

if ($binaryOutput) {
    $outFormat = 99;    # shortest possible output format
    $mainTool->Options(PrintConv => 0);
    unless ($textOut or $binaryStdout) {
        binmode(STDOUT);
        $binaryStdout = 1;
    }
    # disable conflicting options
    undef $showGroup;
}

# sort by groups to look nicer depending on options
if (defined $showGroup and not (@tags and $allGroup)) {
    $mainTool->Options(Sort => "Group$showGroup");
}

if (defined $textOut) {
    CleanFilename($textOut);  # make all forward slashes
    # add '.' before output extension if necessary
    $textOut = ".$textOut" unless $textOut =~ /[.%]/;
}

# determine if we should scan for only writable files
if ($outOpt) {
    my $type = GetFileType($outOpt);
    if ($type) {
        unless (CanWrite($type)) {
            Warn "Can't write $type files\n";
            $rtnVal = 1;
            next;
        }
        $scanWritable = $type unless CanCreate($type);
    } else {
        $scanWritable = 1;
    }
    $isWriting = 1;     # set writing flag
} elsif ($isWriting or defined $deleteOrig) {
    $scanWritable = 1;
}

# set flag to fix description lengths if necessary
$fixLen = ($utf8 and $mainTool->Options('Lang') ne 'en' and eval 'require Encode');

# sort input files if specified
if (@fileOrder) {
    my @allFiles;
    ProcessFiles(undef, \@allFiles);
    my $sortTool = new Image::ExifTool;
    $sortTool->Options(PrintConv => $mainTool->Options('PrintConv'));
    $sortTool->Options(Duplicates => 0);
    my (%sortBy, %isFloat, @rev, $file);
    # save reverse sort flags
    push @rev, (s/^-// ? 1 : 0) foreach @fileOrder;
    foreach $file (@allFiles) {
        my @tags;
        my $info = $sortTool->ImageInfo($file, @fileOrder, \@tags);
        # get values of all tags (or '~' to sort last if not defined)
        foreach (@tags) {
            $_ = $$info{$_};
            defined $_ or $_ = '~', next;
            $isFloat{$_} = 1 if /^[+-]?(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
        }
        $sortBy{$file} = \@tags;    # save tag values for each file
    }
    # sort in specified order
    @files = sort {
        my ($i, $cmp);
        for ($i=0; $i<@rev; ++$i) {
            my $u = $sortBy{$a}[$i];
            my $v = $sortBy{$b}[$i];
            if (not $isFloat{$u} and not $isFloat{$v}) {
                $cmp = $u cmp $v;               # alphabetically
            } elsif ($isFloat{$u} and $isFloat{$v}) {
                $cmp = $u <=> $v;               # numerically
            } else {
                $cmp = $isFloat{$u} ? -1 : 1;   # numbers first
            }
            return $rev[$i] ? -$cmp : $cmp if $cmp;
        }
        return $a cmp $b;   # default to sort by name
    } @allFiles;
} elsif (defined $progress) {
    # expand FILE argument to count the number of files to process
    my @allFiles;
    ProcessFiles(undef, \@allFiles);
    @files = @allFiles;
}
# set file count for progress message
$progressMax = scalar @files if defined $progress;

# store duplicate database information under canonical filenames
my @dbKeys = keys %database;
if (@dbKeys and require Cwd) {
    foreach (@dbKeys) {
        my $canonFile = Cwd::abs_path($_);
        if (defined $canonFile) {
            $database{$canonFile} = $database{$_} unless $database{$canonFile};
        } else {
            # (may happen on Mac if the filename encoding is incorrect in the database)
            Warn "Error generating canonical filename for $_\n";
        }
    }
}

# process all specified files
ProcessFiles($mainTool);

if ($filtered and not $validFile) {
    Warn "No file with specified extension\n";
    $rtnVal = 1;
}

# print CSV information if necessary
PrintCSV() if $csv and not $isWriting;

# print file trailer if necessary
print $fileTrailer if $fileTrailer and not $textOut and not $fileHeader;

if (defined $deleteOrig) {

    # print summary and delete requested files
    unless ($quiet) {
        printf "%5d directories scanned\n", $countDir if $countDir;
        printf "%5d directories created\n", $countNewDir if $countNewDir;
        printf "%5d files failed condition\n", $countFailed if $countFailed;
        printf "%5d image files found\n", $count;
    }
    if (@delFiles) {
        # verify deletion unless "-delete_original!" was specified
        if ($deleteOrig == 1) {
            printf '%5d originals will be deleted!  Are you sure [y/n]? ', scalar(@delFiles);
            my $response = <STDIN>;
            unless ($response =~ /^(y|yes)\s*$/i) {
                Warn "Originals not deleted.\n";
                next;
            }
        }
        $countGoodWr = unlink @delFiles;
        $countBad = scalar(@delFiles) - $countGoodWr;
    }
    if ($quiet) {
        # no more messages
    } elsif ($count and not $countGoodWr and not $countBad) {
        printf "%5d original files found\n", $countGoodWr;
    } elsif ($deleteOrig) {
        printf "%5d original files deleted\n", $countGoodWr if $count;
        printf "%5d originals not deleted due to errors\n", $countBad if $countBad;
    } else {
        printf "%5d image files restored from original\n", $countGoodWr if $count;
        printf "%5d files not restored due to errors\n", $countBad if $countBad;
    }

} elsif (not $binaryStdout and not $quiet) {

    # print summary
    my $tot = $count + $countBad;
    my $totWr = $countGoodWr + $countBadWr + $countSameWr + $countCopyWr +
                $countGoodCr + $countBadCr;
    if ($countDir or $totWr or $countFailed or $tot > 1 or $textOut) {
        my $o = (($html or $json or $xml or %printFmt or $csv) and not $textOut) ? \*STDERR : \*STDOUT;
        printf($o "%5d directories scanned\n", $countDir) if $countDir;
        printf($o "%5d directories created\n", $countNewDir) if $countNewDir;
        printf($o "%5d files failed condition\n", $countFailed) if $countFailed;
        printf($o "%5d image files created\n", $countGoodCr) if $countGoodCr;
        printf($o "%5d image files updated\n", $countGoodWr) if $totWr - $countGoodCr - $countBadCr - $countCopyWr;
        printf($o "%5d image files unchanged\n", $countSameWr) if $countSameWr;
        printf($o "%5d image files copied\n", $countCopyWr) if $countCopyWr;
        printf($o "%5d files weren't updated due to errors\n", $countBadWr) if $countBadWr;
        printf($o "%5d files weren't created due to errors\n", $countBadCr) if $countBadCr;
        printf($o "%5d image files read\n", $count) if $tot>1 or ($countDir and not $totWr);
        printf($o "%5d files could not be read\n", $countBad) if $countBad;
        printf($o "%5d output files created\n", $countCreated) if $textOut;
    }
}

# set error status if we had any errors or if all files failed the "-if" condition
$rtnVal = 1 if $countBadWr or $countBadCr or $countBad or ($countFailed and not $count);

# last ditch effort to preserve filemodifydate
PreserveTime() if %preserveTime;

} # end "Command" loop ........................................................

close STAYOPEN if $stayOpen >= 2;

Exit $rtnVal;   # all done


#------------------------------------------------------------------------------
# Get image information from EXIF data in file
# Inputs: 0) ExifTool object reference, 1) file name
sub GetImageInfo($$)
{
    my ($exifTool, $orig) = @_;
    my (@foundTags, $info, $file, $ind);

    # determine the name of the source file based on the original input file name
    if (@srcFmt) {
        my ($fmt, $first);
        foreach $fmt (@srcFmt) {
            $file = $fmt eq '@' ? $orig : FilenameSPrintf($fmt, $orig);
            # use this file if it exists
            -e $file and undef($first), last;
            $verbose and print "Source file $file does not exist\n";
            $first = $file unless defined $first;
        }
        $file = $first if defined $first;
    } else {
        $file = $orig;
    }

    my $pipe = $file;
    if ($doUnzip) {
        # pipe through gzip or bzip2 if necessary
        if ($file =~ /\.gz$/i) {
            $pipe = qq{gzip -dc "$file" |};
        } elsif ($file =~ /\.bz2$/i) {
            $pipe = qq{bzip2 -dc "$file" |};
        }
    }
    # evaluate -if expression for conditional processing
    if (defined $condition) {
        unless ($file eq '-' or -e $file) {
            Warn "File not found: $file\n";
            ++$countBad;
            return;
        }
        # catch run time errors as well as compile errors
        undef $evalWarning;
        local $SIG{'__WARN__'} = sub { $evalWarning = $_[0] };

        my %info;
        # extract information and build expression for evaluation
        my $opts = { Duplicates => 1, Verbose => 0, HtmlDump => 0 };
        # return all tags but explicitly mention tags on command line so
        # requested images will generate the appropriate warnings
        @foundTags = ('*', @tags) if @tags;
        $info = $exifTool->ImageInfo($pipe, \@foundTags, $opts);
        my $cond = $exifTool->InsertTagValues(\@foundTags, $condition, \%info);

        #### eval "-if" condition (%info)
        my $result = eval $cond;

        $@ and $evalWarning = $@;
        if ($evalWarning) {
            # fail condition if warning is issued
            undef $result;
            if ($verbose) {
                chomp $evalWarning;
                $evalWarning =~ s/ at \(eval .*//s;
                delete $SIG{'__WARN__'};
                Warn "Condition: $evalWarning - $file\n";
            }
        }
        unless ($result) {
            $verbose and print "-------- $file (failed condition)$progStr\n";
            ++$countFailed;
            return;
        }
        # can't make use of $info if verbose because we must reprocess
        # the file anyway to generate the verbose output
        undef $info if $verbose;
    }
    if (defined $deleteOrig) {
        print "======== $file$progStr\n" if defined $verbose;
        ++$count;
        my $original = "${file}_original";
        -e $original or return;
        if ($deleteOrig) {
            $verbose and print "Scheduled for deletion: $original\n";
            push @delFiles, $original;
        } elsif (rename $original, $file) {
            $verbose and print "Restored from $original\n";
            ++$countGoodWr;
        } else {
            Warn "Error renaming $original\n";
            ++$countBad;
        }
        return;
    }
    my $lineCount = 0;
    my ($fp, $outfile);
    if ($textOut and $verbose) {
        ($fp, $outfile) = OpenOutputFile($orig);
        $fp or ++$countBad, return;
        $tmpText = $outfile;    # deletes file if we exit prematurely
        $exifTool->Options(TextOut => $fp);
    }

    if ($isWriting) {
        print "======== $file$progStr\n" if defined $verbose;
        SetImageInfo($exifTool, $file, $orig);
        $info = $exifTool->GetInfo('Warning', 'Error');
        PrintErrors($exifTool, $info, $file);
        # close output text file if necessary
        if ($outfile) {
            undef $tmpText;
            close($fp);
            $exifTool->Options(TextOut => \*STDOUT);
            if ($info->{Error}) {
                unlink $outfile;    # erase bad file
            } else {
                ++$countCreated;
            }
        }
        return;
    }

    # extract information from this file
    unless ($file eq '-' or -e $file) {
        Warn "File not found: $file\n";
        $outfile and close($fp), undef($tmpText), unlink($outfile);
        ++$countBad;
        return;
    }
    # print file/progress message
    my $o;
    unless ($binaryOutput or $textOut or %printFmt or $html > 1 or $csv) {
        if ($html) {
            require Image::ExifTool::HTML;
            my $f = Image::ExifTool::HTML::EscapeHTML($file);
            print "<!-- $f -->\n";
        } elsif (not ($json or $xml)) {
            $o = \*STDOUT if ($multiFile and not $quiet) or $progress;
        }
    }
    $o = \*STDERR if $progress and not $o;
    $o and print $o "======== $file$progStr\n";
    if ($info) {
        # get the information we wanted
        if (@tags and not %printFmt) {
            @foundTags = @tags;
            $info = $exifTool->GetInfo(\@foundTags);
        }
    } else {
        # request specified tags unless using print format option
        my $oldDups = $exifTool->Options('Duplicates');
        if (%printFmt) {
            $exifTool->Options(Duplicates => 1);
            $exifTool->Options(RequestAll => 1);
        } else {
            @foundTags = @tags;
        }
        # extract the information
        $info = $exifTool->ImageInfo($pipe, \@foundTags);
        $exifTool->Options(Duplicates => $oldDups);
    }
    # all done now if we already wrote output text file (ie. verbose option)
    if ($fp) {
        if ($outfile) {
            $exifTool->Options(TextOut => \*STDOUT);
            undef $tmpText;
            if ($info->{Error}) {
                close($fp);
                unlink $outfile;    # erase bad file
            } else {
                ++$lineCount;       # output text file (likely) is not empty
            }
        }
        if ($info->{Error}) {
            Warn "Error: $info->{Error} - $file\n";
            ++$countBad;
            return;
        }
    }

    # print warnings to stderr if using binary output
    # (because we are likely ignoring them and piping stdout to file)
    # or if there is none of the requested information available
    if ($binaryOutput or not %$info) {
        my $errs = $exifTool->GetInfo('Warning', 'Error');
        PrintErrors($exifTool, $errs, $file);
    }

    # open output file (or stdout if no output file) if not done already
    unless ($fp) {
        ($fp, $outfile) = OpenOutputFile($orig);
        $fp or ++$countBad, return;
    }

    # print the results for this file
    if (%printFmt) {
        # output using print format file (-p) option
        my ($type, $doc, $grp);
        undef $fileTrailer;
        # repeat for each embedded document if necessary
        my $lastDoc = $exifTool->Options('ExtractEmbedded') ? $exifTool->{DOC_COUNT} : 0;
        foreach $type ('HEAD', 'BODY', 'TAIL') {
            my $prf = $printFmt{$type} or next;
            for ($doc=0; $doc<=$lastDoc; ++$doc) {
                if ($lastDoc) {
                    if ($doc) {
                        last unless $type eq 'BODY'; # only repeat BODY lines
                        $grp = "Doc$doc:";
                    } else {
                        $grp = 'Main:';
                    }
                    # change tag groups to print next document by adding "Main:" or "Doc#:"
                    # to all tags which don't already start with a family 3 group name
                    $prf = [ @{$printFmt{$type}} ];
                    s/((^|[^\$])(\$\$)*\$\{?)((?!(Main|Doc\d+):)[\w])/$1$grp$4/ig foreach @$prf;
                }
                my @lines;
                foreach (@$prf) {
                    my $line = $exifTool->InsertTagValues(\@foundTags, $_, 'Warn');
                    push @lines, $line if defined $line;
                }
                $lineCount += scalar @lines;
                if ($type eq 'TAIL') {
                    $fileTrailer = '' unless defined $fileTrailer;
                    $fileTrailer .= join '', @lines;
                } elsif (@lines) {
                    print $fp @lines;
                }
            }
        }
        delete $printFmt{HEAD} unless $outfile; # print header only once per output file
        my $errs = $exifTool->GetInfo('Warning', 'Error');
        PrintErrors($exifTool, $errs, $file);
    } elsif (not $disableOutput) {
        # print file header (only once)
        if ($fileHeader) {
            print $fp $fileHeader;
            undef $fileHeader unless $textOut;
        }
        my ($tag, $line, %noDups, %csvInfo, $bra, $ket, $sep);
        if ($html) {
            print $fp "<table>\n";
        } elsif ($xml) {
            my $f = $file;
            CleanXML(\$f);
            print $fp "\n<rdf:Description rdf:about='$f'";
            print $fp "\n  xmlns:et='http://ns.exiftool.ca/1.0/'";
            print $fp " et:toolkit='Image::ExifTool $Image::ExifTool::VERSION'";
            # define namespaces for all tag groups
            my %groups;
            foreach $tag (@foundTags) {
                my ($grp, $grp1) = $exifTool->GetGroup($tag);
                unless ($grp1) {
                    next unless $forcePrint;
                    $grp = $grp1 = 'Unknown';
                }
                next if $groups{$grp1};
                $groups{$grp1} = 1;
                # include family 0 and 1 groups in URI except for internal tags
                # (this will put internal tags in the "XML" group on readback)
                $grp .= "/$grp1" unless $grp eq $grp1 and
                                        $grp =~ /^(ExifTool|File|Composite|Unknown)$/;
                print $fp "\n  xmlns:$grp1='http://ns.exiftool.ca/$grp/1.0/'";
            }
            print $fp '>' if $outFormat < 1; # finish rdf:Description token unless short format
            $ind = $outFormat >= 0 ? ' ' : '   ';
        } elsif ($json) {
            # set delimiters for JSON or PHP output
            ($bra, $ket, $sep) = $json == 1 ? ('{','}',':') : ('Array(',')',' =>');
            print $fp ",\n" if $comma;
            print $fp qq($bra\n  "SourceFile"$sep ), EscapeJSON($file, 1);
            $comma = 1;
            $ind = (defined $showGroup and not $allGroup) ? '    ' : '  ';
        } elsif ($csv) {
            $database{$file} = \%csvInfo;
            push @csvFiles, $file;
        }
        # suppress duplicates manually in JSON and short XML output
        my $noDups = ($json or ($xml and $outFormat > 0));
        my $printConv = $mainTool->Options('PrintConv');
        my $lastGroup = '';
        foreach $tag (@foundTags) {
            my $tagName = GetTagName($tag);
            my $group;
            # make sure this tag has a value
            my $val = $$info{$tag};
            if (ref $val) {
                if (defined $binaryOutput and not $binaryOutput) { # happens with -X -b or -php -b
                    # avoid extracting Protected binary tags (ie. data blocks) [insider information]
                    next if $exifTool->{TAG_INFO}{$tag}{Protected};
                }
                $val = ConvertBinary($val); # convert SCALAR references
                if ($structOpt) {
                    # serialize structure if necessary
                    $val = Image::ExifTool::XMP::SerializeStruct($val) unless $xml or $json;
                } elsif (ref $val eq 'ARRAY') {
                    if (defined $listItem) {
                        # take only the specified item
                        $val = $$val[$listItem];
                    # join arrays of simple values (with newlines for binary output)
                    } elsif ($binaryOutput) {
                        $val = join "\n", @$val;
                    } elsif ($joinLists) {
                        $val = join $listSep, @$val;
                    }
                }
            }
            if (not defined $val) {
                # ignore tags that weren't found unless necessary
                next if $binaryOutput;
                if ($forcePrint) {
                    $val = '-';     # forced to print all tag values
                } elsif (not $csv) {
                    next;
                }
            }
            if (defined $showGroup) {
                $group = $exifTool->GetGroup($tag, $showGroup);
                # look ahead to see if this tag may suppress a priority tag in
                # the same group, and if so suppress this tag instead
                next if $noDups and $tag =~ /^([-\w+]( #)?)\(/ and defined $$info{$1} and
                        $group eq $exifTool->GetGroup($1, $showGroup);
                $group = 'Unknown' if not $group and ($xml or $json);
                unless ($allGroup or $csv) {
                    if ($lastGroup ne $group) {
                        if ($html) {
                            my $cols = 1;
                            ++$cols if $outFormat==0 or $outFormat==1;
                            ++$cols if $showTagID;
                            print $fp "<tr><td colspan=$cols bgcolor='#dddddd'>$group</td></tr>\n";
                        } elsif ($json) {
                            print $fp "\n  $ket" if $lastGroup;
                            print $fp ',' if $lastGroup or $comma;
                            print $fp qq(\n  "$group"$sep $bra);
                            undef $comma;
                            undef %noDups;  # allow duplicate names in different groups
                        } else {
                            print $fp "---- $group ----\n";
                        }
                        $lastGroup = $group;
                    }
                    undef $group;   # undefine so we don't print it below
                }
            }

            ++$lineCount;           # we are printing something meaningful

            # write binary output
            if ($binaryOutput) {
                print $fp $val;
                next;
            }
            # save information for CSV output
            if ($csv) {
                my $t = $group ? "$group:$tagName" : $tagName;
                $t .= '#' if $tag =~ /#/;   # add ValueConv "#" suffix if used
                # (tag-name case may be different if some tags don't exist
                # in a file, so all logic must use lower-case tag names)
                my $lcTag = lc $t;
                # override existing entry only if top priority
                next if defined $csvInfo{$lcTag} and $tag =~ /\(/;
                $csvInfo{$lcTag} = $val;
                if (defined $csvTags{$lcTag}) {
                    # overwrite with actual extracted tag name
                    # (note: can't check "if defined $val" here because -f may be used)
                    $csvTags{$lcTag} = $t if defined $$info{$tag};
                } else {
                    # (don't save unextracted tag name unless -f was used)
                    $csvTags{$lcTag} = defined($val) ? $t : '';
                    if (@csvFiles == 1) {
                        push @csvTags, $lcTag; # save order of tags for first file
                    } elsif (@csvTags) {
                        undef @csvTags;
                    }
                }
                next;
            }

            # get description if we need it (use tag name if $outFormat > 0)
            my $desc = $outFormat > 0 ? $tagName : $exifTool->GetDescription($tag);

            if ($xml) {
                # RDF/XML output format
                my $tok = "$group:$tagName";
                # manually un-do CR/LF conversion in Windows because output
                # is in text mode, which will re-convert newlines to CR/LF
                $isCRLF and $val =~ s/\x0d\x0a/\x0a/g;
                if ($outFormat > 0) {
                    if ($structOpt and ref $val) {
                        $val = Image::ExifTool::XMP::SerializeStruct($val);
                    }
                    if ($escapeHTML) {
                        $val =~ tr/\0-\x08\x0b\x0c\x0e-\x1f/./;
                        Image::ExifTool::XMP::FixUTF8(\$val) if $utf8;
                        $val = Image::ExifTool::HTML::EscapeHTML($val);
                    } else {
                        CleanXML(\$val);
                    }
                    unless ($noDups{$tok}) {
                        print $fp "\n $tok='$val'";
                        # XML does not allow duplicate attributes
                        $noDups{$tok} = 1;
                    }
                    next;
                }
                my ($xtra, $valNum, $descClose);
                if ($showTagID) {
                    my ($id, $lang) = $exifTool->GetTagID($tag);
                    if ($id =~ /^\d+$/) {
                        $id = sprintf("0x%.4x", $id) if $showTagID eq 'H';
                    } else {
                        $id = Image::ExifTool::XMP::FullEscapeXML($id);
                    }
                    $xtra = " et:id='$id'";
                    $xtra .= " xml:lang='$lang'" if $lang;
                } else {
                    $xtra = '';
                }
                if ($tabFormat) {
                    my $table = $exifTool->GetTableName($tag);
                    my $index = $exifTool->GetTagIndex($tag);
                    $xtra .= " et:table='$table'";
                    $xtra .= " et:index='$index'" if defined $index;
                }
                my $lastVal = $val;
                for ($valNum=0; $valNum<2; ++$valNum) {
                    $val = FormatXML($val, $ind, $group);
                    if ($outFormat >= 0) {
                        # normal output format (note: this will give
                        # non-standard RDF/XML if there are any attributes)
                        print $fp "\n <$tok$xtra$val</$tok>";
                        last;
                    } elsif ($valNum == 0) {
                        CleanXML(\$desc);
                        if ($xtra) {
                            print $fp "\n <$tok>";
                            print $fp "\n  <rdf:Description$xtra>";
                            $descClose = "\n  </rdf:Description>";
                        } else {
                            print $fp "\n <$tok rdf:parseType='Resource'>";
                            $descClose = '';
                        }
                        # print tag Description
                        print $fp "\n   <et:desc>$desc</et:desc>";
                        if ($printConv) {
                            # print PrintConv value
                            print $fp "\n   <et:prt$val</et:prt>";
                            $val = $exifTool->GetValue($tag, 'ValueConv');
                            $val = '' unless defined $val;
                            # go back to print ValueConv value only if different
                            if (ref $val ne 'SCALAR' and $val ne $lastVal) {
                                next if ref $val ne 'ARRAY' or ref $lastVal ne 'ARRAY' or
                                    @$val ne @$lastVal;
                                # test all elements of an array
                                my $i = 0;
                                for ($i=0; $i<scalar(@$val); ++$i) {
                                    last if $$val[$i] ne $$lastVal[$i];
                                }
                                next if $i < scalar(@$val);
                            }
                            print $fp "$descClose\n </$tok>";
                            last;
                        }
                    }
                    # print ValueConv value
                    print $fp "\n   <et:val$val</et:val>";
                    print $fp "$descClose\n </$tok>";
                    last;
                }
                next;
            } elsif ($json) {
                # JSON or PHP output format
                my $tok = $allGroup ? "$group:$tagName" : $tagName;
                # (removed due to backward incompatibility)
                # $tok .= '#' if $tag =~ /#/; # add back '#' suffix if used
                next if $noDups{$tok};
                $noDups{$tok} = 1;
                print $fp ',' if $comma;
                print $fp qq(\n$ind"$tok"$sep );
                FormatJSON($fp, $val, $ind);
                $comma = 1;
                next;
            }
            my $id;
            if ($showTagID) {
                $id = $exifTool->GetTagID($tag);
                if ($id =~ /^(\d+)(\.\d+)?$/) { # only print numeric ID's
                    $id = sprintf("0x%.4x", $1) if $showTagID eq 'H';
                } else {
                    $id = '-';
                }
            }

            # translate unprintable chars in value and remove trailing spaces
            $val =~ tr/\x01-\x1f\x7f/./;
            $val =~ s/\x00//g;
            $val =~ s/\s+$//;

            if ($html) {
                print $fp "<tr>";
                print $fp "<td>$group</td>" if defined $group;
                print $fp "<td>$id</td>" if $showTagID;
                print $fp "<td>$desc</td>" if $outFormat <= 1;
                print $fp "<td>$val</td></tr>\n";
            } else {
                my $buff = '';
                if ($tabFormat) {
                    $buff = "$group\t" if defined $group;
                    $buff .= "$id\t" if $showTagID;
                    if ($outFormat <= 1) {
                        $buff .= "$desc\t$val\n";
                    } elsif (defined $line) {
                        $line .= "\t$val";
                    } else {
                        $line = $val;
                    }
                } elsif ($outFormat < 0) {    # long format
                    $buff = "[$group] " if defined $group;
                    $buff .= "$id " if $showTagID;
                    $buff .= "$desc\n      $val\n";
                } elsif ($outFormat == 0 or $outFormat == 1) {
                    my $wid;
                    my $len = 0;
                    if (defined $group) {
                        $buff = sprintf("%-15s ", "[$group]");
                        $len = 16;
                    }
                    if ($showTagID) {
                        $wid = ($showTagID eq 'D') ? 5 : 6;
                        $len += $wid + 1;
                        ($wid = $len - length($buff) - 1) < 1 and $wid = 1;
                        $buff .= sprintf "%${wid}s ", $id;
                    }
                    $wid = 32 - (length($buff) - $len);
                    # pad description to a constant length
                    # (get actual character length when using alternate languages
                    # because these descriptions may contain UTF8-encoded characters)
                    my $padLen = $wid - length($fixLen ? Encode::decode_utf8($desc) : $desc);
                    $padLen = 0 if $padLen < 0;
                    $buff .= $desc . (' ' x $padLen) . ": $val\n";
                } elsif ($outFormat == 2) {
                    $buff = "[$group] " if defined $group;
                    $buff .= "$id " if $showTagID;
                    $buff .= "$tagName: $val\n";
                } elsif ($argFormat) {
                    $buff = '-';
                    $buff .= "$group:" if defined $group;
                    $tagName .= '#' if $tag =~ /#/; # add '#' suffix if used
                    $buff .= "$tagName=$val\n";
                } else {
                    $buff = "$group " if defined $group;
                    $buff .= "$id " if $showTagID;
                    $buff .= "$val\n";
                }
                print $fp $buff;
            }
        }
        if ($html) {
            print $fp "</table>\n";
        } elsif ($xml) {
            # close rdf:Description element
            print $fp $outFormat < 1 ? "\n</rdf:Description>\n" : "/>\n";
        } elsif ($json) {
            print $fp "\n  $ket" if $lastGroup;
            print $fp "\n$ket";
            $comma = 1;
        } elsif ($tabFormat and $outFormat > 1) {
            print $fp "$line\n" if defined $line;
        }
    }
    if ($outfile) {
        print $fp $fileTrailer if $fileTrailer; # write file trailer
        close($fp);
        undef $comma;
        if ($lineCount) {
            ++$countCreated;
        } else {
            unlink $outfile; # don't keep empty output files
        }
    }
    ++$count;
}

#------------------------------------------------------------------------------
# Set information in file
# Inputs: 0) ExifTool object reference, 1) source file name
#         2) original source file name ('' to create from scratch)
# Returns: true on success
sub SetImageInfo($$$)
{
    my ($exifTool, $file, $orig) = @_;
    my ($outfile, $restored, $isTemporary, $isStdout, $outType, $tagsFromSrc);
    my $infile = $file;    # save infile in case we change it again

    undef $tmpFile; # make sure this isn't defined

    # clear any existing errors or warnings since we check these on return
    delete $exifTool->{VALUE}->{Error};
    delete $exifTool->{VALUE}->{Warning};

    # first, try to determine our output file name so we can return quickly
    # if it already exists (note: this test must be delayed until after we
    # set tags from dynamic files if writing FileName or Directory)
    if (defined $outOpt) {
        if ($outOpt =~ /^-(\.\w+)?$/) {
            # allow output file type to be specified with "-o -.EXT"
            $outType = GetFileType($outOpt) if $1;
            $outfile = '-';
            $isStdout = 1;
        } else {
            $outfile = FilenameSPrintf($outOpt, $orig);
            if ($outfile eq '') {
                Warn "Can't create file with zero-length name from $orig\n";
                ++$countBadCr;
                return 0;
            }
        }
        if (not $isStdout and (-d $outfile or $outfile =~ /\/$/)) {
            $outfile .= '/' unless $outfile =~ /\/$/;
            my $name = $file;
            $name =~ s/.*\///;  # remove directory name
            $outfile .= $name;
        } else {
            my $srcType = GetFileType($file) || '';
            $outType or $outType = GetFileType($outfile);
            if ($outType and ($srcType ne $outType or $outType eq 'ICC')) {
                unless (CanCreate($outType)) {
                    my $what = $srcType ? 'other types' : 'scratch';
                    WarnOnce "Error: Can't create $outType files from $what\n";
                    ++$countBadCr;
                    return 0;
                }
                if ($file ne '') {
                    # restore previous new values unless done already
                    $exifTool->RestoreNewValues() unless $restored;
                    $restored = 1;
                    # translate to this type by setting specified tags from file
                    my @setTags = @tags;
                    foreach (@exclude) {
                        push @setTags, "-$_";
                    }
                    # force some tags to be copied for certain file types
                    my %forceCopy = (
                        ICC => 'ICC_Profile',
                        VRD => 'CanonVRD',
                    );
                    push @setTags, $forceCopy{$outType} if $forceCopy{$outType};
                    # assume "-tagsFromFile @" unless -tagsFromFile already specified
                    # (%setTags won't be empty if -tagsFromFile used)
                    if (not %setTags or (@setTags and not $setTags{'@'})) {
                        return 0 unless DoSetFromFile($exifTool, $file, \@setTags);
                    } elsif (@setTags) {
                        # add orphaned tags to existing "-tagsFromFile @" for this file only
                        push @setTags, @{$setTags{'@'}};
                        $tagsFromSrc = \@setTags;
                    }
                    # all done with source file -- create from meta information alone
                    $file = '';
                }
            }
        }
        unless ($isStdout) {
            $outfile = NextUnusedFilename($outfile);
            if (-e $outfile and not $doSetFileName) {
                Warn "Error: '$outfile' already exists - $infile\n";
                ++$countBadWr;
                return 0;
            }
        }
    } elsif ($file eq '-') {
        $isStdout = 1;
    }
    # set tags from destination file if required
    if (@dynamicFiles) {
        # restore previous values if necessary
        $exifTool->RestoreNewValues() unless $restored;
        my ($dyFile, %setTagsIndex);
        foreach $dyFile (@dynamicFiles) {
            if (not ref $dyFile) {
                my ($fromFile, $setTags);
                if ($dyFile eq '@') {
                    $fromFile = $orig;
                    $setTags = $tagsFromSrc || $setTags{$dyFile};
                } else {
                    $fromFile = FilenameSPrintf($dyFile, $orig);
                    ++$countBadWr, return 0 unless defined $fromFile;
                    $setTags = $setTags{$dyFile};
                }
                # do we have multiple -tagsFromFile options with this file?
                if ($setTagsList{$dyFile}) {
                    # use the tags set in the i-th occurrence
                    my $i = $setTagsIndex{$dyFile} || 0;
                    $setTagsIndex{$dyFile} = $i + 1;
                    $setTags = $setTagsList{$dyFile}[$i] if $setTagsList{$dyFile}[$i];
                }
                # set new values values from file
                return 0 unless DoSetFromFile($exifTool, $fromFile, $setTags);
            } elsif (ref $dyFile eq 'ARRAY') {
                # a dynamic file containing a simple tag value
                my $fname = FilenameSPrintf($$dyFile[1], $orig);
                my ($buff, $rtn, $wrn);
                my $opts = $$dyFile[2];
                if (defined $fname and SlurpFile($fname, \$buff)) {
                    $verbose and print "Reading $$dyFile[0] from $fname\n";
                    ($rtn, $wrn) = $mainTool->SetNewValue($$dyFile[0], $buff, %$opts);
                    $wrn and Warn "$wrn\n";
                }
                # remove this tag if we couldn't set it properly
                $rtn or $mainTool->SetNewValue($$dyFile[0], undef, Replace => 2,
                                               ProtectSaved => $$opts{ProtectSaved});
                next;
            } elsif (ref $dyFile eq 'SCALAR') {
                # set new values from CSV database
                my ($f, $found, $tag);
                # read tags for SourceFile '*' plus the specific file
                foreach $f ('*', $file) {
                    my $csvInfo = $database{$f};
                    unless ($csvInfo) {
                        next if $f eq '*' or not require Cwd;
                        # check canonical file name
                        $csvInfo = $database{Cwd::abs_path($f)} or next;
                    }
                    $found = 1;
                    $verbose and print "Setting new values from $csv database\n";
                    foreach $tag (sort keys %$csvInfo) {
                        next if $tag =~ /\b(SourceFile|Directory|FileName)$/i; # don't write these
                        my ($rtn, $wrn) = $mainTool->SetNewValue($tag, $$csvInfo{$tag},
                                          Protected => 1, AddValue => $csvAdd,
                                          ProtectSaved => $csvSaveCount);
                        $wrn and Warn "$wrn\n" if $verbose;
                    }
                }
                unless ($found) {
                    Warn("No SourceFile '$file' in imported $csv database\n");
                    if (require Cwd) {
                        my $cFile = Cwd::abs_path($file);
                        Warn("(canonical path: '$cFile')\n");
                    }
                    return 0;
                }
            }
        }
    }
    if ($isStdout) {
        # write to STDOUT
        $outfile = \*STDOUT;
        unless ($binaryStdout) {
            binmode(STDOUT);
            $binaryStdout = 1;
        }
    } else {
        # determine what our output file name should be
        my $newFileName = $exifTool->GetNewValues('FileName');
        my $newDir = $exifTool->GetNewValues('Directory');
        if (defined $newFileName or defined $newDir or ($doSetFileName and defined $outfile)) {
            if ($newFileName) {
                $newFileName = FilenameSPrintf($newFileName, $orig);
                if (defined $outfile) {
                    $outfile = Image::ExifTool::GetNewFileName($orig, $outfile) if $orig ne '';
                    $outfile = Image::ExifTool::GetNewFileName($outfile, $newFileName);
                } elsif ($orig ne '') {
                    $outfile = Image::ExifTool::GetNewFileName($orig, $newFileName);
                }
            }
            if ($newDir) {
                $newDir = FilenameSPrintf($newDir, $orig);
                $outfile = Image::ExifTool::GetNewFileName(defined $outfile ? $outfile : $orig, $newDir);
            }
            $outfile = NextUnusedFilename($outfile, $infile);
            if (-e $outfile) {
                if ($infile ne $outfile) {
                    Warn "Error: '$outfile' already exists - $infile\n";
                    ++$countBadWr;
                    return 0;
                }
                undef $outfile; # not changing the file name after all
            }
        }
        if (defined $outfile) {
            $verbose and print "'$infile' --> '$outfile'\n";
            # create output directory if necessary
            CreateDirectory($outfile);
            # set temporary file (automatically erased on abnormal exit)
            $tmpFile = $outfile if defined $outOpt;
        }
        unless (defined $tmpFile) {
            # count the number of tags and pseudo-tags we are writing
            my ($numSet, $numPseudo) = $exifTool->CountNewValues();
            if (-e $file) {
                unless ($numSet) {
                    # no need to write if no tags set
                    print "Nothing changed in $file\n" if defined $verbose;
                    ++$countSameWr;
                    return 1;
                }
            } elsif (CanCreate($file)) {
                if ($numSet == $numPseudo) {
                    # no need to write if no real tags
                    Warn("Error: Nothing to write - $file\n");
                    ++$countBadWr;
                    return 0;
                }
                unless (defined $outfile) {
                    # create file from scratch
                    $outfile = $file;
                    $file = '';
                }
            } else {
                # file doesn't exist, and we can't create it
                Warn("Error: File not found - $file\n");
                ++$countBadWr;
                return 0;
            }
            # quickly rename file and/or set file date if this is all we are doing
            if ($numSet == $numPseudo) {
                my $r1 = $exifTool->SetFileModifyDate($file,undef,'FileCreateDate');
                my $r2 = $exifTool->SetFileModifyDate($file);
                my $r3 = 0;
                $r3 = $exifTool->SetFileName($file, $outfile) if defined $outfile;
                if ($r1 > 0 or $r2 > 0 or $r3 > 0) {
                    ++$countGoodWr;
                } elsif ($r1 < 0 or $r2 < 0 or $r3 < 0) {
                    ++$countBadWr;
                    return 0;
                } else {
                    ++$countSameWr;
                }
                return 1;
            }
            unless (defined $outfile) {
                # write to a truly temporary file
                $outfile = "${file}_exiftool_tmp";
                if (-e $outfile) {
                    Warn("Error: Temporary file already exists: $outfile\n");
                    ++$countBadWr;
                    return 0;
                }
                $isTemporary = 1;
            }
            # new output file is temporary until we know it has been written properly
            $tmpFile = $outfile;
        }
    }
    # rewrite the file
    my $success = $exifTool->WriteInfo($file, $outfile, $outType);

    # get file time if preserving it
    my ($aTime, $mTime, $cTime);
    if ($preserveTime and $success and -e $file) {
        $aTime = $^T - (-A _) * (24 * 3600);
        $mTime = $^T - (-M _) * (24 * 3600);
        $cTime = $^T - (-C _) * (24 * 3600);
    }
    if ($success == 1) {
        # preserve the original file times
        if (defined $tmpFile) {
            if (-e $file) {
                SetFileTime($tmpFile, $aTime, $mTime, $cTime) if $preserveTime;
                if ($isTemporary) {
                    # preserve original file attributes if possible
                    Image::ExifTool::CopyFileAttrs($file, $outfile);
                    # move original out of the way
                    my $original = "${file}_original";
                    if (not $overwriteOrig and not -e $original) {
                        # rename the file and check again to be sure the file doesn't exist
                        # (in case, say, the filesystem truncated the file extension)
                        if (not Rename($file, $original) or -e $file) {
                            Error "Error renaming $file\n";
                            return 0;
                        }
                    }
                    if ($overwriteOrig > 1) {
                        # copy temporary file over top of original to preserve attributes
                        my ($err, $buff);
                        my $newFile = $tmpFile;
                        Open(\*NEW_FILE, $newFile) or Error("Error opening $newFile\n"), return 0;
                        binmode(NEW_FILE);

                        #..........................................................
                        # temporarily disable CTRL-C during this critical operation
                        $critical = 1;
                        undef $tmpFile;     # handle deletion of temporary file ourself
                        if (Open(\*ORIG_FILE, $file, '>')) {
                            binmode(ORIG_FILE);
                            while (read(NEW_FILE, $buff, 65536)) {
                                print ORIG_FILE $buff or $err = 1;
                            }
                            close(NEW_FILE);
                            close(ORIG_FILE) or $err = 1;
                            if ($err) {
                                Warn "Couldn't overwrite in place - $file\n";
                                unless (rename($newFile, $file) or
                                    (unlink $file and Rename($newFile, $file)))
                                {
                                    Error("Error renaming $newFile to $file\n"), return 0;
                                }
                            } else {
                                unlink $newFile;
                                if ($preserveTime) {
                                    SetFileTime($file, $aTime, $mTime, $cTime);
                                    # save time to set it later again to patch OS X 10.6 bug
                                    $preserveTime{$file} = [ $aTime, $mTime, $cTime ];
                                }
                            }
                            ++$countGoodWr;
                        } else {
                            close(NEW_FILE);
                            Warn "Error opening $file for writing\n";
                            unlink $newFile;
                            ++$countBadWr;
                        }
                        undef $critical;            # end critical section
                        SigInt() if $interrupted;   # issue delayed SIGINT if necessary
                        #..........................................................

                    # simply rename temporary file to replace original
                    # (if we didn't already rename it to add "_original")
                    } elsif (Rename($tmpFile, $file)) {
                        ++$countGoodWr;
                    } else {
                        my $newFile = $tmpFile;
                        undef $tmpFile; # (avoid deleting file if we get interrupted)
                        # unlink may fail if already renamed or no permission
                        if (not unlink($file)) {
                            Warn "Error renaming temporary file to $file\n";
                            unlink $newFile;
                            ++$countBadWr;
                        # try renaming again now that the target has been deleted
                        } elsif (not Rename($newFile, $file)) {
                            Warn "Error renaming temporary file to $file\n";
                            # (don't delete tmp file now because it is all we have left)
                            ++$countBadWr;
                        } else {
                            ++$countGoodWr;
                        }
                    }
                } elsif ($overwriteOrig) {
                    # erase original file
                    unlink $file or Warn "Error erasing original $file\n";
                    ++$countGoodWr;
                } else {
                    ++$countGoodCr;
                }
            } else {
                # this file was created from scratch, not edited
                ++$countGoodCr;
            }
        } else {
            ++$countGoodWr;
        }
    } elsif ($success) {
        if ($isTemporary) {
            # just erase the temporary file since no changes were made
            unlink $tmpFile;
            ++$countSameWr;
        } else {
            SetFileTime($outfile, $aTime, $mTime, $cTime) if defined $aTime;
            if ($overwriteOrig) {
                unlink $file or Warn "Error erasing original $file\n";
            }
            ++$countCopyWr;
        }
        print "Nothing changed in $file\n" if defined $verbose;
    } else {
        unlink $tmpFile if defined $tmpFile;
        ++$countBadWr;
    }
    undef $tmpFile;
    return $success;
}

#------------------------------------------------------------------------------
# Clean string for XML (also removes invalid control chars and malformed UTF-8)
# Inputs: 0) string ref
# Returns: nothing, but input string is escaped
sub CleanXML($)
{
    my $strPt = shift;
    # translate control characters that are invalid in XML
    $$strPt =~ tr/\0-\x08\x0b\x0c\x0e-\x1f/./;
    # fix malformed UTF-8 characters
    Image::ExifTool::XMP::FixUTF8($strPt) if $utf8;
    # escape necessary characters for XML
    $$strPt = Image::ExifTool::XMP::EscapeXML($$strPt);
}

#------------------------------------------------------------------------------
# Encode string for XML
# Inputs: 0) string ref
# Returns: encoding used (and input string is translated)
sub EncodeXML($)
{
    my $strPt = shift;
    if ($$strPt =~ /[\0-\x08\x0b\x0c\x0e-\x1f]/ or
        ($utf8 and Image::ExifTool::XMP::IsUTF8($strPt) < 0))
    {
        # encode binary data and non-UTF8 with special characters as base64
        $$strPt = Image::ExifTool::XMP::EncodeBase64($$strPt);
        return 'http://www.w3.org/2001/XMLSchema#base64Binary'; #ATV
    } elsif ($escapeHTML) {
        $$strPt = Image::ExifTool::HTML::EscapeHTML($$strPt);
    } else {
        $$strPt = Image::ExifTool::XMP::EscapeXML($$strPt);
    }
    return '';  # not encoded
}

#------------------------------------------------------------------------------
# Format value for XML output
# Inputs: 0) value, 1) indentation, 2) group
# Returns: formatted value
sub FormatXML($$$)
{
    local $_;
    my ($val, $ind, $grp) = @_;
    my $gt = '>';
    if (ref $val eq 'ARRAY') {
        # convert ARRAY into an rdf:Bag
        my $val2 = "\n$ind <rdf:Bag>";
        foreach (@$val) {
            $val2 .= "\n$ind  <rdf:li" . FormatXML($_, "$ind  ", $grp) . "</rdf:li>";
        }
        $val = "$val2\n$ind </rdf:Bag>\n$ind";
    } elsif (ref $val eq 'HASH') {
        $gt = " rdf:parseType='Resource'>";
        my $val2 = '';
        foreach (sort keys %$val) {
            my $tok = $grp . ':' . $_;
            $val2 .= "\n$ind <$tok" . FormatXML($$val{$_}, "$ind ", $grp) . "</$tok>";
        }
        $val = "$val2\n$ind";
    } else {
        # (note: SCALAR reference should have already been converted)
        my $enc = EncodeXML(\$val);
        $gt = " rdf:datatype='$enc'>\n" if $enc; #ATV
    }
    return $gt . $val;
}

#------------------------------------------------------------------------------
# Escape string for JSON or PHP
# Inputs: 0) string, 1) flag to force numbers to be quoted too
# Returns: Escaped string (quoted if necessary)
sub EscapeJSON($;$)
{
    my ($str, $quote) = @_;
    unless ($quote) {
        # JSON boolean (true or false)
        return lc($str) if $str =~ /^(true|false)$/i and $json < 2;
        # JSON/PHP number (see json.org for numerical format)
        # return $str if $str =~ /^-?(\d|[1-9]\d+)(\.\d+)?(e[-+]?\d+)?$/i;
        # (these big numbers caused problems for some JSON parsers, so be more conservative)
        return $str if $str =~ /^-?(\d|[1-9]\d{1,14})(\.\d{1,16})?(e[-+]?\d{1,3})?$/i;
    }
    # escape special characters
    $str =~ s/(["\t\n\r\\])/\\$jsonChar{$1}/sg;
    if ($json < 2) { # JSON
        # escape other control characters with \u
        $str =~ s/([\0-\x1f])/sprintf("\\u%.4X",ord $1)/sge;
        # JSON strings must be valid UTF8
        Image::ExifTool::XMP::FixUTF8(\$str) if $utf8;
    } else { # PHP
        # must escape "$" too for PHP
        $str =~ s/\$/\\\$/sg;
        # escape other control characters with \x
        $str =~ s/([\0-\x1f])/sprintf("\\x%.2X",ord $1)/sge;
    }
    return '"' . $str . '"';    # return the quoted string
}

#------------------------------------------------------------------------------
# Print JSON or PHP value
# Inputs: 0) file reference, 1) value, 2) indentation
sub FormatJSON($$$)
{
    local $_;
    my ($fp, $val, $ind) = @_;
    my $comma;
    if (not ref $val) {
        print $fp EscapeJSON($val);
    } elsif (ref $val eq 'ARRAY') {
        if ($joinLists and not ref $$val[0]) {
            print $fp EscapeJSON(join $listSep, @$val);
        } else {
            my ($bra, $ket) = $json == 1 ? ('[',']') : ('Array(',')');
            print $fp $bra;
            foreach (@$val) {
                print $fp ',' if $comma;
                FormatJSON($fp, $_, $ind);
                $comma = 1,
            }
            print $fp $ket,
        }
    } elsif (ref $val eq 'HASH') {
        my ($bra, $ket, $sep) = $json == 1 ? ('{','}',':') : ('Array(',')',' =>');
        print $fp $bra;
        foreach (sort keys %$val) {
            print $fp ',' if $comma;
            print $fp qq(\n$ind  "$_"$sep );
            FormatJSON($fp, $$val{$_}, "$ind  ");
            $comma = 1,
        }
        print $fp "\n$ind$ket",
    } else {
        # (note: SCALAR reference should have already been converted)
        print $fp '"<err>"';
    }
}

#------------------------------------------------------------------------------
# Format value for CSV file
# Inputs: value
# Returns: value quoted if necessary
sub FormatCSV($)
{
    my $val = shift;
    $val = qq{"$val"} if $val =~ s/"/""/g or $val =~ /(^\s+|\s+$)/ or $val =~ /[,\n\r]/;
    return $val;
}

#------------------------------------------------------------------------------
# Print accumulated CSV information
sub PrintCSV()
{
    my ($file, $lcTag, @tags);

    @csvTags or @csvTags = sort keys %csvTags;
    # make a list of tags actually found
    foreach $lcTag (@csvTags) {
        push @tags, $csvTags{$lcTag} if $csvTags{$lcTag};
    }
    print join(',', 'SourceFile', @tags), "\n";
    my $empty = $forcePrint ? '-' : '';
    foreach $file (@csvFiles) {
        my @vals = (FormatCSV($file));  # start with full file name
        my $csvInfo = $database{$file};
        foreach $lcTag (@csvTags) {
            next unless $csvTags{$lcTag};
            my $val = $$csvInfo{$lcTag};
            defined $val or push(@vals,$empty), next;
            push @vals, FormatCSV($val);
        }
        print join(',', @vals), "\n";
    }
}

#------------------------------------------------------------------------------
# Convert binary data (SCALAR references) for printing
# Inputs: 0) object reference
# Returns: converted object
sub ConvertBinary($)
{
    my $obj = shift;
    my ($key, $val);
    if (ref $obj eq 'HASH') {
        foreach $key (keys %$obj) {
            $$obj{$key} = ConvertBinary($$obj{$key}) if ref $$obj{$key};
        }
    } elsif (ref $obj eq 'ARRAY') {
        foreach $val (@$obj) {
            $val = ConvertBinary($val) if ref $val;
        }
    } elsif (ref $obj eq 'SCALAR') {
        # (binaryOutput flag is set to 0 for binary mode of XML/PHP output formats)
        if (defined $binaryOutput) {
            $obj = $$obj;
        } else {
            # (-b is not valid for JSON or HTML output)
            my $bOpt = ($json==1 or $html) ? '' : ', use -b option to extract';
            if ($$obj =~ /^Binary data/) {
                $obj = "($$obj$bOpt)";
            } else {
                $obj = '(Binary data ' . length($$obj) . " bytes$bOpt)";
            }
        }
    }
    return $obj;
}

#------------------------------------------------------------------------------
# Add tag list for copying tags from specified file
# Inputs: 0) set tags file name (or FMT), 1) options for SetNewValuesFromFile()
# Returns: nothing
# Notes: Uses global variables: %setTags, %setTagsList, @newValues, $saveCount
sub AddSetTagsFile($;$)
{
    my ($setFile, $opts) = @_;
    if ($setTags{$setFile}) {
        # move these tags aside and make a new list for the next invocation of this file
        $setTagsList{$setFile} or $setTagsList{$setFile} = [ ];
        push @{$setTagsList{$setFile}}, $setTags{$setFile};
    }
    $setTags{$setFile} = [];    # create list for tags to copy from this file
    # insert marker to save new values now (necessary even if this is not a dynamic
    # file in case the same file is source'd multiple times in a single command)
    push @newValues, { SaveCount => ++$saveCount }, "TagsFromFile=$setFile";
    # add option to protect the tags which are assigned after this
    # (this is the mechanism by which the command-line order-of-operations is preserved)
    $opts or $opts = { };
    $$opts{ProtectSaved} = $saveCount;
    push @{$setTags{$setFile}}, $opts;
}

#------------------------------------------------------------------------------
# Set new values from file
# Inputs: 0) exiftool ref, 1) filename, 2) reference to list of values to set
# Returns: 0 on error (and increments $countBadWr)
sub DoSetFromFile($$$)
{
    local $_;
    my ($exifTool, $file, $setTags) = @_;
    $verbose and print "Setting new values from $file\n";
    my $info = $exifTool->SetNewValuesFromFile($file, @$setTags);
    my $numSet = scalar(keys %$info);
    if ($$info{Error}) {
        # delete all error and warning tags
        my @warns = grep /^(Error|Warning)\b/, keys %$info;
        $numSet -= scalar(@warns);
        # issue a warning for the main error only if we were able to set some tags
        if (keys(%$info) > @warns) {
            my $err = $$info{Error};
            delete $$info{$_} foreach @warns;
            $$info{Warning} = $err;
        }
    } elsif ($$info{Warning}) {
        my $warns = 1;
        ++$warns while $$info{"Warning ($warns)"};
        $numSet -= $warns;
    }
    PrintErrors($exifTool, $info, $file);
    $$info{Error} and ++$countBadWr, return 0;
    Warn "Warning: No writable tags set from $file\n" unless $numSet;
    return 1;
}

#------------------------------------------------------------------------------
# Translate backslashes to forward slashes in filename if necessary
# Inputs: 0) Filename
# Returns: nothing, but changes filename if necessary
sub CleanFilename($)
{
    $_[0] =~ tr/\\/\// if $hasBackslash{$^O};
}

#------------------------------------------------------------------------------
# process files in our @files list
# Inputs: 0) ExifTool ref, 1) list ref to just return full file names
# Notes: arg 0 is not used if arg 1 is defined
sub ProcessFiles($;$)
{
    my ($exifTool, $list) = @_;
    my $file;
    foreach $file (@files) {
        if (defined $progressMax) {
            ++$progress;
            $progStr = " [$progress/$progressMax]";
        }
        if (-d $file) {
            $multiFile = $validFile = 1;
            ScanDir($mainTool, $file, $list);
        } elsif ($filterFlag and not AcceptFile($file)) {
            if (-e $file) {
                $filtered = 1;
                $verbose and print "-------- $file (wrong extension)$progStr\n";
            } else {
                Warn "File not found: $file\n";
                $rtnVal = 1;
            }
        } else {
            $validFile = 1;
            $list and push(@$list, $file), next;
            GetImageInfo($exifTool, $file);
        }
    }
}

#------------------------------------------------------------------------------
# Scan directory for image files
# Inputs: 0) ExifTool ref, 1) directory name, 2) list ref to return file names
sub ScanDir($$;$)
{
    my ($exifTool, $dir, $list) = @_;
    opendir(DIR_HANDLE, $dir) or Warn("Error opening directory $dir\n"), return;
    my @fileList = readdir(DIR_HANDLE);
    closedir(DIR_HANDLE);

    my $file;
    $dir =~ /\/$/ or $dir .= '/';
    foreach $file (@fileList) {
        my $path = "$dir$file";
        if (-d $path) {
            next unless $recurse and $file !~ /^\./; # ignore dirs starting with "."
            next if $ignore{$file} or ($ignore{SYMLINKS} and -l $path);
            ScanDir($exifTool, $path, $list);
            next;
        }
        # apply rules from -ext options
        my $accepted;
        if ($filterFlag) {
            $accepted = AcceptFile($file) or next;
            # must be specifically accepted to bypass selection logic
            $accepted &= 0x01;
        }
        unless ($accepted) {
            # read/write this file if it is a supported type
            if ($scanWritable) {
                if ($scanWritable eq '1') {
                    next unless CanWrite($file);
                } else {
                    my $type = GetFileType($file);
                    next unless defined $type and $type eq $scanWritable;
                }
            } elsif (not GetFileType($file)) {
                next unless $doUnzip;
                next unless $file =~ /\.(gz|bz2)$/i;
            }
        }
        $list and push(@$list, $path), next;
        GetImageInfo($exifTool, $path);
    }
    ++$countDir;
}

#------------------------------------------------------------------------------
# Set file system times
# Inputs: 0) file name, 1) access time, 2) modification time, 3) creation time
# Notes: issues warning if modification/access times can't be set
sub SetFileTime($@)
{
    my ($file, $aTime, $mTime, $cTime) = @_;
    unless (utime($aTime, $mTime, $file)) {
        Warn "Error setting file time - $file\n";
    }
    # set creation time for Windows systems only (if Win32API::File::Time is available)
    if ($^O eq 'MSWin32' and eval 'require Win32API::File::Time') {
        Win32API::File::Time::SetFileTime($file,undef,undef,$cTime);
    }
}

#------------------------------------------------------------------------------
# patch for OS X 10.6 to preserve file modify date
# (this probably isn't a 100% fix, but it may solve a majority of the cases)
sub PreserveTime()
{
    local $_;
    SetFileTime($_, @{$preserveTime{$_}}) foreach keys %preserveTime;
    undef %preserveTime;
}

#------------------------------------------------------------------------------
# Add print format entry
# Inputs: 0) expression string
sub AddPrintFormat($)
{
    my $expr = shift;
    my $type;
    if ($expr =~ /^#/) {
        $expr =~ s/^#\[(HEAD|BODY|TAIL)\]// or return; # ignore comments
        $type = $1;
    } else {
        $type = 'BODY';
    }
    $printFmt{$type} or $printFmt{$type} = [ ];
    push @{$printFmt{$type}}, $expr;
    # add to list of requested tags
    push @tags, $expr =~ /\$((?:[-\w]+:)*[-\w]+#?)/g;
    # tags contained in braces too...
    push @tags, $expr =~ /\$\{((?:[-\w]+:)*[-\w]+#?)\}/g;
}

#------------------------------------------------------------------------------
# Load print format file
# Inputs: 0) file name
# - saves lines of file to %printFmt list
# - adds tag names to @tags list
sub LoadPrintFormat($)
{
    my $arg = shift;
    if (not defined $arg) {
        Error "Must specify file or expression for -p option\n";
    } elsif (-f $arg and Open(\*FMT_FILE, $arg)) {
        foreach (<FMT_FILE>) {
            AddPrintFormat($_);
        }
        close(FMT_FILE);
    } else {
        AddPrintFormat($arg . "\n");
    }
}

#------------------------------------------------------------------------------
# A sort of sprintf for filenames
# Inputs: 0) format string (%d=dir, %f=file name, %e=ext),
#         1) source filename or undef to test format string
# Returns: new filename or undef on error (or if no file and fmt contains token)
sub FilenameSPrintf($;$)
{
    my ($fmt, $file) = @_;
    local $_;
    # return format string straight away if no tokens
    return $fmt unless $fmt =~ /%[-+]?\d*[.:]?\d*[lu]?[dfe]/;
    return undef unless defined $file;
    CleanFilename($file);   # make sure we are using forward slashes
    # split filename into directory, file, extension
    my @parts = ($file =~ /^(.*?)([^\/]*?)(\.[^.\/]*)?$/);
    $parts[2] = $parts[2] ? substr($parts[2], 1) : '';
    @parts or Warn("Error: Bad pattern match for file $file\n"), return undef;
    my (%part, $len, $part);
    $part{$_} = shift @parts foreach ('d','f','e');
    my ($filename, $pos) = ('', 0);
    while ($fmt =~ /(%([-+]?)(\d*)([.:]?)(\d*)([lu]?)([dfe]))/g) {
        $filename .= substr($fmt, $pos, pos($fmt) - $pos - length($1));
        $pos = pos($fmt);
        my ($sign, $wid, $dot, $skip, $mod, $code) = ($2, $3, $4, $5 || 0, $6, $7);
        my @path;
        if ($code eq 'd' and $dot and $dot eq ':') {
            # field width applies to directory levels instead of characters
            @path = split '/', $part{d};
            $len = scalar @path;
        } else {
            $len = length $part{$code};
        }
        next unless $skip < $len;
        $wid = $len - $skip if $wid eq '' or $wid + $skip > $len;
        $skip = $len - $wid - $skip if $sign eq '-';
        if (@path) {
            $part = join('/', @path[$skip..($skip+$wid-1)]) . '/';
        } else {
            $part = substr($part{$code}, $skip, $wid);
        }
        $part = ($mod eq 'u') ? uc($part) : lc($part) if $mod;
        $filename .= $part;
    }
    $filename .= substr($fmt, $pos); # add rest of file name
    # remove double slashes (except at beginning to allow Windows UNC paths)
    $filename =~ s{(?!^)//}{/}g;
    return $filename;
}

#------------------------------------------------------------------------------
# Convert number to alphabetical index: a, b, c, ... z, aa, ab ...
# Inputs: 0) number
# Returns: alphabetical index string
sub Num2Alpha($)
{
    my $num = shift;
    my $alpha = chr(97 + ($num % 26));
    while ($num >= 26) {
        $num = int($num / 26) - 1;
        $alpha = chr(97 + ($num % 26)) . $alpha;
    }
    return $alpha;
}

#------------------------------------------------------------------------------
# Expand '%c' and '%C' codes if filename to get next unused file name
# Inputs: 0) file name format string, 1) filename ok to use even if it exists
# Returns: new file name
sub NextUnusedFilename($;$)
{
    my ($fmt, $okfile) = @_;
    return $fmt unless $fmt =~ /%[-+]?\d*\.?\d*[lun]?[cC]/;
    my %sep = ( '-' => '-', '+' => '_' );
    my ($copy, $alpha) = (0, 'a');
    for (;;) {
        my ($filename, $pos) = ('', 0);
        while ($fmt =~ /(%([-+]?)(\d*)(\.?)(\d*)([lun]?)([cC]))/g) {
            $filename .= substr($fmt, $pos, pos($fmt) - $pos - length($1));
            $pos = pos($fmt);
            my ($sign, $wid, $dec, $wid2, $mod, $tok) = ($2, $3 || 0, $4, $5 || 0, $6, $7);
            if ($tok eq 'C') {
                $seqFileNum = $wid if $wid and not $seqFileNum;
                $wid = $wid2;
            } else {
                next unless $dec or $copy;
                $wid = $wid2 if $wid < $wid2;
            }
            # add dash or underline separator if '-' or '+' specified
            $filename .= $sep{$sign} if $sign;
            if ($mod and $mod ne 'n') {
                my $a = $tok eq 'C' ? Num2Alpha($seqFileNum++) : $alpha;
                my $str = ($wid and $wid > length $a) ? 'a' x ($wid - length($a)) : '';
                $str .= $a;
                $str = uc $str if $mod eq 'u';
                $filename .= $str;
            } else {
                my $c = $tok eq 'C' ? $seqFileNum++ : $copy;
                my $num = $c + ($mod ? 1 : 0);
                $filename .= $wid ? sprintf("%.${wid}d",$num) : $num;
            }
        }
        $filename .= substr($fmt, $pos); # add rest of file name
        # return now with filename unless file exists
        return $filename unless -e $filename;
        return $filename if defined $okfile and $filename eq $okfile;
        ++$copy;
        ++$alpha;
    }
}

#------------------------------------------------------------------------------
# Create directory for specified file
# Inputs: 0) complete file name including path
# Returns: true if a directory was created
sub CreateDirectory($)
{
    my $file = shift;
    my ($dir, $created);
    ($dir = $file) =~ s/[^\/]*$//;  # remove filename from path specification
    if ($dir and not -d $dir) {
        my @parts = split /\//, $dir;
        $dir = '';
        foreach (@parts) {
            $dir .= $_;
            if (length $dir and not -d $dir and
                # don't try to create a network drive root directory
                not ($hasBackslash{$^O} and $dir =~ m{^//[^/]*$}))
            {
                # create directory since it doesn't exist
                mkdir($dir, 0777) or Error("Error creating directory $dir\n"), return 0;
                $verbose and print "Created directory $dir\n";
                $created = 1;
            }
            $dir .= '/';
        }
    }
    ++$countNewDir if $created;
    return $created;
}

#------------------------------------------------------------------------------
# Open output text file
# Inputs: 0) file name format string
# Returns: 0) file reference (or undef on error), 1) file name if opened
sub OpenOutputFile($)
{
    my $file = shift;
    my ($fp, $outfile);
    if ($textOut) {
        $outfile = $file;
        CleanFilename($outfile);
        if ($textOut =~ /%[-+]?\d*[.:]?\d*[lun]?[dfecC]/) {
            # make filename from printf-like $textOut
            $outfile = FilenameSPrintf($textOut, $file);
            return () unless defined $outfile;
            $outfile = NextUnusedFilename($outfile);
            CreateDirectory($outfile);  # create directory if necessary
        } else {
            $outfile =~ s/\.[^.\/]*$//; # remove extension if it exists
            $outfile .= $textOut;
        }
        if (-e $outfile and not $textOverwrite) {
            Warn "Output file $outfile already exists for $file\n";
            return ();
        }
        Open(\*OUTFILE, $outfile, '>') or Error("Error creating $outfile\n"), return ();
        binmode(OUTFILE) if $binaryOutput;
        $fp = \*OUTFILE;
    } else {
        $fp = \*STDOUT;
    }
    return($fp, $outfile);
}

#------------------------------------------------------------------------------
# Filter files based on extension
# Inputs: 0) file name
# Returns: 0 = rejected, 1 = specifically accepted, 2 = accepted by default
# Notes: This routine should only be called if $filterFlag is set
sub AcceptFile($)
{
    my $file = shift;
    my $ext = ($file =~ /.*\.(.+)$/) ? uc($1) : '';
    return $filterExt{$ext} if defined $filterExt{$ext};
    return $filterExt{'*'} if defined $filterExt{'*'};
    return 0 if $filterFlag & 0x02; # reject if accepting specific extensions
    return 2;   # accept by default
}

#------------------------------------------------------------------------------
# Rename a file (patch for Windows denial-of-service susceptibility)
# Inputs: 0) old name, 1) new name
# Returns: true on success
sub Rename($$)
{
    my ($old, $new) = @_;
    my $result = rename($old, $new);

    if (not $result and $^O eq 'MSWin32') {
        my $try = 2;
        for (;;) {
            select(undef,undef,undef,0.01); # sleep for 0.01 sec
            $result = rename($old, $new);
            last if $result or ++$try > 50; # retry for 0.5 seconds
        }
        Warn("It took $try tries to rename $new\n") if $result;
    }
    return $result;
}

#------------------------------------------------------------------------------
# Slurp file into buffer
# Inputs: 0) file name, 1) buffer reference
# Returns: 1 on success
sub SlurpFile($$)
{
    my ($file, $buffPt) = @_;
    Open(\*INFILE, $file) or Warn("Error opening file $file\n"), return 0;
    binmode(INFILE);
    my $bsize = 1024 * 1024;
    my $num = read(INFILE, $$buffPt, $bsize);
    unless (defined $num) {
        close(INFILE);
        Warn("Error reading $file\n");
        return 0;
    }
    my $bmax = 64 * $bsize;
    while ($num == $bsize) {
        $bsize *= 2 if $bsize < $bmax;
        my $buff;
        $num = read(INFILE, $buff, $bsize);
        last unless $num;
        $$buffPt .= $buff;
    }
    close(INFILE);
    return 1;
}

#------------------------------------------------------------------------------
# Read arguments from -stay_open argfile
# Inputs: 0) argument list ref
# Notes: blocks until -execute, -stay_open or -@ option is available
#        (or until there was an error reading from the file)
sub ReadStayOpen($)
{
    my $args = shift;
    my (@newArgs, $processArgs, $result, $optArgs);
    my $lastOpt = '';
    my $unparsed = length $stayOpenBuff;
    for (;;) {
        if ($unparsed) {
            # parse data already read from argfile
            $result = $unparsed;
            undef $unparsed;
        } else {
            # read more data from argfile
            # - this read may block (which is good) if reading from a pipe
            $result = sysread(STAYOPEN, $stayOpenBuff, 65536, length($stayOpenBuff));
        }
        if ($result) {
            my $pos = 0;
            while ($stayOpenBuff =~ /\n/g) {
                my $len = pos($stayOpenBuff) - $pos;
                my $arg = substr($stayOpenBuff, $pos, $len);
                $pos += $len;
                $arg =~ s/^\s+//;           # remove leading white space
                $arg =~ s/[\x0d\x0a]+$//s;  # remove trailing newline
                # remove white space before, and single space after '=', '+=', '-=' or '<='
                $arg =~ s/^(-[-:\w]+#?)\s*([-+<]?=) ?/$1$2/;
                next if $arg eq '' or $arg =~ /^#/; # ignore empty/comment lines
                push @newArgs, $arg;
                if ($optArgs) {
                    # this is an argument for the last option
                    undef $optArgs;
                    next unless $lastOpt eq '-stay_open' or $lastOpt eq '-@';
                } else {
                    $optArgs = $optArgs{$arg};
                    $lastOpt = lc $arg;
                    $optArgs = $optArgs{$lastOpt} unless defined $optArgs;
                    next unless $lastOpt =~ /^-execute\d*$/;
                }
                $processArgs = 1;
                last;   # process arguments up to this point
            }
            next unless $pos;   # nothing to do if we didn't read any arguments
            # keep unprocessed data in buffer
            $stayOpenBuff = substr($stayOpenBuff, $pos);
            if ($processArgs) {
                # process new arguments after -execute or -stay_open option
                unshift @$args, @newArgs;
                last;
            }
        } elsif ($result == 0) {
            # sysread() didn't block (ie. when reading from a file),
            # so wait for a short time (1/100 sec) then try again
            # Note: may break out of this early if SIGCONT is received
            select(undef,undef,undef,0.01);
        } else {
            Warn "Error reading from ARGFILE\n";
            close STAYOPEN;
            $stayOpen = 0;
            last;
        }
    }
}

#------------------------------------------------------------------------------
# Print list of tags
# Inputs: 0) message, 1-N) list of tag names
sub PrintTagList($@)
{
    my $msg = shift;
    print $msg, ":\n" unless $quiet;
    print ' ';
    my $len = 1;
    my $tag;
    foreach $tag (@_) {
        my $taglen = length($tag);
        if ($len + $taglen > 78) {
            print "\n ";
            $len = 1;
        }
        print " $tag";
        $len += $taglen + 1;
    }
    @_ or print ' [empty list]';
    print "\n";
}

#------------------------------------------------------------------------------
# Print warnings and errors from info hash
# Inputs: 0) ExifTool object ref, 1) info hash, 2) file name
sub PrintErrors($$$)
{
    my ($exifTool, $info, $file) = @_;
    my ($tag, $key);
    foreach $tag (qw(Warning Error)) {
        next unless $$info{$tag};
        my @keys = ( $tag );
        push @keys, sort(grep /^$tag /, keys %$info) if $exifTool->Options('Duplicates');
        foreach $key (@keys) {
            Warn "$tag: $info->{$key} - $file\n";
        }
    }
}

__END__

=head1 NAME

exiftool - Read and write meta information in files

=head1 SYNOPSIS

=over 4

=item B<exiftool> [I<OPTIONS>] [-I<TAG>...] [--I<TAG>...] I<FILE>...

=item B<exiftool> [I<OPTIONS>] -I<TAG>[+-E<lt>]=[I<VALUE>]... I<FILE>...

=item B<exiftool> [I<OPTIONS>] B<-tagsFromFile> I<SRCFILE>
[-I<SRCTAG>[E<gt>I<DSTTAG>]...] I<FILE>...

=item B<exiftool> [ B<-ver> |
B<-list>[B<w>|B<f>|B<r>|B<wf>|B<g>[I<NUM>]|B<d>|B<x>] ]

=back

For specific examples, see the L<EXAMPLES|/READING EXAMPLES> sections below.

This documentation is displayed if exiftool is run without an input I<FILE>
when one is expected.

=head1 DESCRIPTION

A command-line interface to L<Image::ExifTool|Image::ExifTool>, used for
reading and writing meta information in a variety of file types.  I<FILE> is
one or more source file names, directory names, or C<-> for the standard
input.  Information is read from source files and printed in readable form
to the console (or written to output text files with B<-w>).

To write or delete information, tag values are assigned using the
-I<TAG>=[I<VALUE>] syntax, or the B<-geotag> option.  To copy or move
information, the B<-tagsFromFile> feature is used.  By default the original
files are preserved with C<_original> appended to their names -- be sure to
verify that the new files are OK before erasing the originals.  Once in
write mode, exiftool will ignore any read-specific options.

Note:  If I<FILE> is a directory name then only supported file types in the
directory are processed (in write mode only writable types are processed).
However, files may be specified by name, or the B<-ext> option may be used
to force processing of files with any extension.

Below is a list of file types and meta information formats currently
supported by ExifTool (r = read, w = write, c = create):

  File Types
  ------------+-------------+-------------+-------------+------------
  3FR   r     | EIP   r     | LNK   r     | PAC   r     | RWL   r/w
  3G2   r     | EPS   r/w   | M2TS  r     | PAGES r     | RWZ   r
  3GP   r     | ERF   r/w   | M4A/V r     | PBM   r/w   | RM    r
  ACR   r     | EXE   r     | MEF   r/w   | PCD   r     | SO    r
  AFM   r     | EXIF  r/w/c | MIE   r/w/c | PDF   r/w   | SR2   r/w
  AI    r/w   | EXR   r     | MIFF  r     | PEF   r/w   | SRF   r
  AIFF  r     | F4A/V r     | MKA   r     | PFA   r     | SRW   r/w
  APE   r     | FFF   r/w   | MKS   r     | PFB   r     | SVG   r
  ARW   r/w   | FLA   r     | MKV   r     | PFM   r     | SWF   r
  ASF   r     | FLAC  r     | MNG   r/w   | PGF   r     | THM   r/w
  AVI   r     | FLV   r     | MOS   r/w   | PGM   r/w   | TIFF  r/w
  BMP   r     | FPX   r     | MOV   r     | PICT  r     | TTC   r
  BTF   r     | GIF   r/w   | MP3   r     | PMP   r     | TTF   r
  CHM   r     | GZ    r     | MP4   r     | PNG   r/w   | VRD   r/w/c
  COS   r     | HDP   r/w   | MPC   r     | PPM   r/w   | VSD   r
  CR2   r/w   | HDR   r     | MPG   r     | PPT   r     | WAV   r
  CRW   r/w   | HTML  r     | MPO   r/w   | PPTX  r     | WDP   r/w
  CS1   r/w   | ICC   r/w/c | MQV   r     | PS    r/w   | WEBP  r
  DCM   r     | IDML  r     | MRW   r/w   | PSB   r/w   | WEBM  r
  DCP   r/w   | IIQ   r/w   | MXF   r     | PSD   r/w   | WMA   r
  DCR   r     | IND   r/w   | NEF   r/w   | PSP   r     | WMV   r
  DFONT r     | INX   r     | NRW   r/w   | QTIF  r     | WV    r
  DIVX  r     | ITC   r     | NUMBERS r   | RA    r     | X3F   r/w
  DJVU  r     | J2C   r     | ODP   r     | RAF   r/w   | XCF   r
  DLL   r     | JNG   r/w   | ODS   r     | RAM   r     | XLS   r
  DNG   r/w   | JP2   r/w   | ODT   r     | RAR   r     | XLSX  r
  DOC   r     | JPEG  r/w   | OFR   r     | RAW   r/w   | XMP   r/w/c
  DOCX  r     | K25   r     | OGG   r     | RIFF  r     | ZIP   r
  DV    r     | KDC   r     | OGV   r     | RSRC  r     |
  DVB   r     | KEY   r     | ORF   r/w   | RTF   r     |
  DYLIB r     | LA    r     | OTF   r     | RW2   r/w   |

  Meta Information
  ----------------------+----------------------+---------------------
  EXIF           r/w/c  |  CIFF           r/w  |  Ricoh RMETA    r
  GPS            r/w/c  |  AFCP           r/w  |  Picture Info   r
  IPTC           r/w/c  |  Kodak Meta     r/w  |  Adobe APP14    r
  XMP            r/w/c  |  FotoStation    r/w  |  MPF            r
  MakerNotes     r/w/c  |  PhotoMechanic  r/w  |  Stim           r
  Photoshop IRB  r/w/c  |  JPEG 2000      r    |  APE            r
  ICC Profile    r/w/c  |  DICOM          r    |  Vorbis         r
  MIE            r/w/c  |  Flash          r    |  SPIFF          r
  JFIF           r/w/c  |  FlashPix       r    |  DjVu           r
  Ducky APP12    r/w/c  |  QuickTime      r    |  M2TS           r
  PDF            r/w/c  |  Matroska       r    |  PE/COFF        r
  PNG            r/w/c  |  GeoTIFF        r    |  AVCHD          r
  Canon VRD      r/w/c  |  PrintIM        r    |  ZIP            r
  Nikon Capture  r/w/c  |  ID3            r    |  (and more)

=head1 OPTIONS

Case is not significant for any command-line option (including tag and group
names), except for single-character options when the corresponding
upper-case option exists.  Many single-character options have equivalent
long-name versions (shown in brackets), and some options have inverses which
are invoked with a leading double-dash.  Note that multiple single-character
options may NOT be combined into one argument because this would be
interpreted as a tag name.  Contrary to standard practice, options may
appear after source file names on the exiftool command line.

=head2 Option Summary

L<Tag operations|/Tag operations>

  -TAG or --TAG                    Extract or exclude specified tag
  -TAG[+-]=[VALUE]                 Write new value for tag
  -TAG[+-]<=DATFILE                Write tag value from contents of file
  -TAG[+-]<SRCTAG                  Copy tag value (see -tagsFromFile)

  -tagsFromFile SRCFILE            Copy tag values from file
  -x TAG      (-exclude)           Exclude specified tag

L<Input-output text formatting|/Input-output text formatting>

  -args       (-argFormat)         Format metadata as exiftool arguments
  -b          (-binary)            Output metadata in binary format
  -c FMT      (-coordFormat)       Set format for GPS coordinates
  -charset [[TYPE=]CHARSET]        Specify encoding for special characters
  -csv[=CSVFILE]                   Export/import tags in CSV format
  -d FMT      (-dateFormat)        Set format for date/time values
  -D          (-decimal)           Show tag ID numbers in decimal
  -E, -ex     (-escape(HTML|XML))  Escape values for HTML (-E) or XML (-ex)
  -f          (-forcePrint)        Force printing of all specified tags
  -g[NUM...]  (-groupHeadings)     Organize output by tag group
  -G[NUM...]  (-groupNames)        Print group name for each tag
  -h          (-htmlFormat)        Use HMTL formatting for output
  -H          (-hex)               Show tag ID number in hexadecimal
  -htmlDump[OFFSET]                Generate HTML-format binary dump
  -j[=JSONFILE] (-json)            Export/import tags in JSON format
  -l          (-long)              Use long 2-line output format
  -L          (-latin)             Use Windows Latin1 encoding
  -lang [LANG]                     Set current language
  -listItem INDEX                  Extract specific item from a list
  -n          (--printConv)        Read/write numerical tag values
  -p FMTFILE  (-printFormat)       Print output in specified format
  -php                             Export tags as a PHP Array
  -s[NUM]     (-short)             Short output format
  -S          (-veryShort)         Very short output format
  -sep STR    (-separator)         Set separator string for list items
  -sort                            Sort output alphabetically
  -struct                          Enable output of structured information
  -t          (-tab)               Output in tab-delimited list format
  -T          (-table)             Output in tabular format
  -v[NUM]     (-verbose)           Print verbose messages
  -w[!] EXT   (-textOut)           Write (or overwrite!) output text files
  -X          (-xmlFormat)         Use RDF/XML output format

L<Processing control|/Processing control>

  -a          (-duplicates)        Allow duplicate tags to be extracted
  -e          (--composite)        Do not calculate composite tags
  -ee         (-extractEmbedded)   Extract information from embedded files
  -ext EXT    (-extension)         Process files with specified extension
  -F[OFFSET]  (-fixBase)           Fix the base for maker notes offsets
  -fast[NUM]                       Increase speed for slow devices
  -fileOrder [-]TAG                Set file processing order
  -i DIR      (-ignore)            Ignore specified directory name
  -if EXPR                         Conditionally process files
  -m          (-ignoreMinorErrors) Ignore minor errors and warnings
  -o OUTFILE  (-out)               Set output file or directory name
  -overwrite_original              Overwrite original by renaming tmp file
  -overwrite_original_in_place     Overwrite original by copying tmp file
  -P          (-preserve)          Preserve date/time of original file
  -password PASSWD                 Password for processing protected files
  -progress                        Show file progress count
  -q          (-quiet)             Quiet processing
  -r          (-recurse)           Recursively process subdirectories
  -scanForXMP                      Brute force XMP scan
  -u          (-unknown)           Extract unknown tags
  -U          (-unknown2)          Extract unknown binary tags too
  -z          (-zip)               Read/write compressed information

L<Special features|/Special features>

  -geotag TRKFILE                  Geotag images from specified GPS log
  -globalTimeShift SHIFT           Shift all formatted date/time values
  -use MODULE                      Add features from plug-in module

L<Utilities|/Utilities>

  -delete_original[!]              Delete "_original" backups
  -restore_original                Restore from "_original" backups

L<Other options|/Other options>

  -@ ARGFILE                       Read command-line arguments from file
  -k          (-pause)             Pause before terminating
  -list[w|f|wf|g[NUM]|d|x]         List various exiftool capabilities
  -ver                             Print exiftool version number

L<Advanced options|/Advanced options>

  -common_args                     Define common arguments
  -config CFGFILE                  Specify configuration file name
  -echo[2] TEXT                    Echo text to stdout or stderr
  -execute[NUM]                    Execute multiple commands on one line
  -srcfile FMT                     Set different source file name
  -stay_open FLAG                  Keep reading -@ argfile even after EOF

=head2 Option Details

=head3 Tag operations

=over 5

=item B<->I<TAG>

Extract information for specified tag (ie. C<-CreateDate>).  A tag name
is the handle by which a piece of information is referenced.  See
L<Image::ExifTool::TagNames|Image::ExifTool::TagNames> for documentation on
available tag names.  A tag name may include leading group names separated
by colons (ie. C<-EXIF:CreateDate>, or C<-Doc1:XMP:Creator>), and each group
name may be prefixed by a digit to specify family number (ie.
C<-1IPTC:City>).  Use the B<-listg> option to list available group names by
family.

A special tag name of C<All> may be used to indicate all meta information.
This is particularly useful when a group name is specified to extract all
information in a group (but beware that unless the B<-a> option is also
used, some tags in the group may be suppressed by same-named tags in other
groups).  The wildcard characters C<?> and C<*> may be used in a tag name to
match any single character and zero or more characters respectively.  These
may not be used in a group name, with the exception that a group name of
C<*> (or C<All>) may be used to extract all instances of a tag (as if B<-a>
was used).  Note that arguments containing wildcards must be quoted on the
command line of most systems to prevent shell globbing, and wildcards may
not be used when writing/deleting tags.

A C<#> may be appended to the tag name to disable the print conversion on a
per-tag basis (see the B<-n> option).  This may also be used when writing or
copying tags.

If no tags are specified, all available information is extracted (as if
C<-All> had been specified).

Note:  Descriptions, not tag names, are shown by default when extracting
information.  Use the B<-s> option to see the tag names instead.

=item B<-->I<TAG>

Exclude specified tag from extracted information.  Same as the B<-x> option.
May also be used following a B<-tagsFromFile> option to exclude tags from
being copied, or to exclude groups from being deleted when deleting all
information (ie. C<-all= --exif:all> deletes all but EXIF information).  But
note that this will not exclude individual tags from a group delete.
Instead, individual tags may be recovered using the B<-tagsFromFile> option
(ie. C<-all= -tagsfromfile @ -artist>).  Wildcards are permitted as
described above for B<-TAG>.

=item B<->I<TAG>[+-]B<=>[I<VALUE>]

Write a new value for the specified tag (ie. C<-comment=wow>), or delete the
tag if no I<VALUE> is given (ie. C<-comment=>). C<+=> and C<-=> are used to
add or remove existing entries from a list, or to shift date/time values
(see L<Image::ExifTool::Shift.pl|Image::ExifTool::Shift.pl> for details).
C<+=> may also be used to increment numerical values, and C<-=> may be used
to conditionally delete or replace a tag (see L</WRITING EXAMPLES> for
examples).

I<TAG> may contain a leading family 0 or 1 group name separated by a colon.
If no group name is specified, the tag is created in the preferred group,
and updated in any other location where a same-named tag already exists. 
The preferred group is the first group in the following list where I<TAG> is
valid: 1) EXIF, 2) IPTC, 3) XMP.

The special C<All> tag may be used in this syntax only if a I<VALUE> is NOT
given.  This causes all meta information to be deleted (or all information
in a group if C<-GROUP:All=> is used).  Note that not all groups are
deletable, and that the JPEG APP14 "Adobe" group is not removed by default
with C<-All=> because it may affect the appearance of the image.  Use the
B<-listd> option for a complete list of deletable groups.  Also, within an
image some groups may be contained within others, and these groups are
removed if the containing group is deleted:

  JPEG Image:
  - Deleting EXIF or IFD0 also deletes ExifIFD, GlobParamIFD,
    GPS, IFD1, InteropIFD, MakerNotes, PrintIM and SubIFD.
  - Deleting ExifIFD also deletes InteropIFD and MakerNotes.
  - Deleting Photoshop also deletes IPTC.

  TIFF Image:
  - Deleting EXIF only removes ExifIFD which also deletes
    InteropIFD and MakerNotes.

Notes:

1) MakerNotes tags may be edited, but not created or deleted individually. 
This avoids many potential problems including the inevitable compatibility
problems with OEM software which may be very inflexible about the
information it expects to find in the maker notes.

2) Changes to PDF files are reversible because the original information is
never actually deleted from the file.  So ExifTool alone may not be used to
securely edit metadata in PDF files.

Special feature:  Integer values may be specified in hexadecimal with a
leading C<0x>, and simple rational values may be specified as fractions.

=item B<->I<TAG>E<lt>=I<DATFILE> or B<->I<TAG>E<lt>=I<FMT>

Set the value of a tag from the contents of file I<DATFILE>.  The file name
may also be given by a I<FMT> string where %d, %f and %e represent the
directory, file name and extension of the original I<FILE> (see the B<-w>
option for more details).  Note that quotes are required around this
argument to prevent shell redirection since it contains a C<E<lt>> symbol.
C<+E<lt>=> or C<-E<lt>=> may also be used to add or delete specific list
entries, or to shift date/time values.

=item B<-tagsFromFile> I<SRCFILE> or I<FMT>

Copy tag values from I<SRCFILE> to I<FILE>.  Tag names on the command line
after this option specify the tags to be copied, or excluded from the copy.
If no tags are specified, then all possible tags (see note 1 below) from the
source file are copied to same-named tags in the preferred location of the
output file (the same as specifying C<-all>).  More than one
B<-tagsFromFile> option may be used to copy tags from multiple files.

By default, this option will commute information between same-named tags in
different groups and write each tag to the preferred group.  This allows
some information to be automatically translated when copying between images
of different formats.  However, if a group name is specified for a tag then
the information is written to this group (unless redirected to another
group, see below).  If C<All> is used as a group name, then the information
is written to the same family 1 group in the destination file.  In this way,
C<-All:All> is used to copy all information while preserving the family 1
group (ie. the specific location in the metadata) of each tag.

I<SRCFILE> may be the same as I<FILE> to move information around within a
single file.  In this case, C<@> may be used to represent the source file
(ie. C<-tagsFromFile @>), permitting this feature to be used for batch
processing multiple files.  Specified tags are then copied from each file in
turn as it is rewritten.  For advanced batch use, the source file name may
also be specified using a I<FMT> string in which %d, %f and %e represent the
directory, file name and extension of I<FILE>. See B<-w> option for I<FMT>
string examples.

A powerful redirection feature allows a destination tag to be specified for
each copied tag.  With this feature, information may be written to a tag
with a different name or group.  This is done using
E<quot>'-I<SRCTAG>E<gt>I<DSTTAG>'E<quot> or
E<quot>'-I<DSTTAG>E<lt>I<SRCTAG>'E<quot> on the command line after
B<-tagsFromFile>, and causes the value of I<SRCTAG> to be copied from
I<SRCFILE> and written to I<DSTTAG> in I<FILE>.  Note that this argument
must be quoted to prevent shell redirection, and there is no C<=> sign as
when assigning new values.  Source and/or destination tags may be prefixed
by a group name and/or suffixed by C<#>.  Wildcards may be used in the
source tag name only, with the exception that C<All> or C<*> may be used as
a destination group or tag name to represent the same family 1 group or tag
name as the source.  If no destination group is specified, the information
is written to the preferred group.  Whitespace around the C<E<gt>> or
C<E<lt>> is ignored.  As a convenience, C<-tagsFromFile @> is assumed for
any redirected tags which are specified without a prior B<-tagsFromFile>
option.  Copied tags may also be added or deleted from a list with arguments
of the form E<quot>'-I<SRCTAG>+E<gt>I<DSTTAG>'E<quot> or
E<quot>'-I<SRCTAG>-E<gt>I<DSTTAG>'E<quot>.

An extension of the redirection feature allows strings involving tag names
to be used on the right hand side of the C<E<lt>> symbol with the syntax
E<quot>'-I<DSTTAG>E<lt>I<STR>'E<quot>, where tag names in I<STR> are
prefixed with a C<$> symbol.  See the B<-p> option for more details about
this syntax.  Strings starting with a C<=> sign must insert a single space
after the C<E<lt>> to avoid confusion with the C<E<lt>=> operator which sets
the tag value from the contents of a file.  A single space at the start of
the string is removed if it exists, but all other whitespace in the string
is preserved.

See L</COPYING EXAMPLES> for examples using B<-tagsFromFile>.

Notes:

1) Some tags (generally tags which may affect the appearance of the image)
are considered "unsafe" to write, and are only copied if specified
explicitly.  See the L<tag name documentation|Image::ExifTool::TagNames> for
more details about "unsafe" tags.

2) Be aware of the difference between excluding a tag from being copied
(--I<TAG>), and deleting a tag (-I<TAG>=).  Excluding a tag prevents it from
being copied to the destination image, but deleting will remove a
pre-existing tag from the image.

3) The maker note information is copied as a block, so it isn't affected
like other information by subsequent tag assignments on the command line.
Also, since the PreviewImage referenced from the maker notes may be rather
large, it is not copied, and must be transferred separately if desired.

4) The order of operations is to copy all specified tags at the point of the
B<-tagsFromFile> option in the command line.  Any tag assignment to the
right of the B<-tagsFromFile> option is made after all tags are copied.  For
example, new tag values are set in the order One, Two, Three then Four with
this command:

    exiftool -One=1 -tagsFromFile s.jpg -Two -Four=4 -Three d.jpg

This is significant in the case where an overlap exists between the copied
and assigned tags because later operations may override earlier ones.

5) The normal behaviour of copied tags differs subtly from that of assigned
tags for list-type tags.  When copying to a list, each copied tag overrides
any previous operations on the list.  While this avoids duplicate list items
when copying groups of tags from a file containing redundant information, it
also prevents values of different tags from being copied into the same list
when this is the intent.  So a B<-addTagsFromFile> option is provided which
allows copying of multiple tags into the same list.  ie)

    exiftool -addtagsfromfile @ '-subject<make' '-subject<model' ...

Other than this difference, the B<-tagsFromFile> and B<-addTagsFromFile>
options are equivalent.

6) The B<-a> option (allow duplicate tags) is always in effect when reading
tags from I<SRCFILE>.

7) Structured tags are copied by default when copying tags.  See the
B<-struct> option for details.

=item B<-x> I<TAG> (B<-exclude>)

Exclude the specified tag.  There may be multiple B<-x> options.  This has
the same effect as --I<TAG> on the command line.  May also be used following
a B<-tagsFromFile> option to exclude tags from being copied.

=back

=head3 Input-output text formatting

Note that trailing spaces are removed from extracted values for most output
text formats.  The exceptions are C<-b>, C<-csv>, C<-j> and C<-X>.

=over 5

=item B<-args> (B<-argFormat>)

Output information in the form of exiftool arguments, suitable for use with
the B<-@> option when writing.  May be combined with the B<-G> option to
include group names.  This feature may be used to effectively copy tags
between images, but allows the metadata to be altered by editing the
intermediate file (C<out.args> in this example):

    exiftool -args -G1 --filename --directory src.jpg > out.args
    exiftool -@ out.args dst.jpg

Note:  Be careful when copying information with this technique since it is
easy to write tags which are normally considered "unsafe".  For instance,
the FileName and Directory tags are excluded in the example above to avoid
renaming and moving the destination file.  Also note that the second command
above will produce warning messages for any tags which are not writable.

=item B<-b> (B<-binary>)

Output requested metadata in binary format without tag names or
descriptions.  This option is mainly used for extracting embedded images or
other binary data, but it may also be useful for some text strings since
control characters (such as newlines) are not replaced by '.' as they are in
the default output.  List items are separated by a newline when extracted
with the B<-b> option.  May be combined with C<-php> or C<-X> to extract
binary data in PHP or XML format.

=item B<-c> I<FMT> (B<-coordFormat>)

Set the print format for GPS coordinates.  I<FMT> uses the same syntax as
the C<printf> format string.  The specifiers correspond to degrees, minutes
and seconds in that order, but minutes and seconds are optional.  For
example, the following table gives the output for the same coordinate using
various formats:

            FMT                  Output
    -------------------    ------------------
    "%d deg %d' %.2f"\"    54 deg 59' 22.80"  (default for reading)
    "%d %d %.8f"           54 59 22.80000000  (default for copying)
    "%d deg %.4f min"      54 deg 59.3800 min
    "%.6f degrees"         54.989667 degrees

Notes:

1) To avoid loss of precision, the default coordinate format is different
when copying tags using the B<-tagsFromFile> option.

2) If the hemisphere is known, a reference direction (N, S, E or W) is
appended to each printed coordinate, but adding a C<+> to the format
specifier (ie. C<%+.6f>) prints a signed coordinate instead.

3) This print formatting may be disabled with the B<-n> option to extract
coordinates as signed decimal degrees.

=item B<-charset> [[I<TYPE>=]I<CHARSET>]

If I<TYPE> is C<ExifTool> or not specified, this option sets the ExifTool
character encoding for output tag values when reading and input values when
writing.  The default ExifTool encoding is C<UTF8>.  If no I<CHARSET> is
given, a list of available character sets is returned.  Valid I<CHARSET>
values are:

    CHARSET     Alias(es)        Description
    ----------  ---------------  ----------------------------------
    UTF8        cp65001, UTF-8   UTF-8 characters (default)
    Latin       cp1252, Latin1   Windows Latin1 (West European)
    Latin2      cp1250           Windows Latin2 (Central European)
    Cyrillic    cp1251, Russian  Windows Cyrillic
    Greek       cp1253           Windows Greek
    Turkish     cp1254           Windows Turkish
    Hebrew      cp1255           Windows Hebrew
    Arabic      cp1256           Windows Arabic
    Baltic      cp1257           Windows Baltic
    Vietnam     cp1258           Windows Vietnamese
    Thai        cp874            Windows Thai
    MacRoman    cp10000, Roman   Macintosh Roman
    MacLatin2   cp10029          Macintosh Latin2 (Central Europe)
    MacCyrillic cp10007          Macintosh Cyrillic
    MacGreek    cp10006          Macintosh Greek
    MacTurkish  cp10081          Macintosh Turkish
    MacRomanian cp10010          Macintosh Romanian
    MacIceland  cp10079          Macintosh Icelandic
    MacCroatian cp10082          Macintosh Croatian

Other values of I<TYPE> listed below are used to specify the internal
encoding of various meta information formats.

    TYPE       Description                                  Default
    ---------  -------------------------------------------  -------
    EXIF       Internal encoding of EXIF "ASCII" strings    (none)
    ID3        Internal encoding of ID3v1 information       Latin
    IPTC       Internal IPTC encoding to assume when        Latin
                IPTC:CodedCharacterSet is not defined
    Photoshop  Internal encoding of Photoshop IRB strings   Latin
    QuickTime  Internal encoding of QuickTime strings       MacRoman

See L<http://owl.phy.queensu.ca/~phil/exiftool/faq.html#Q10> for more
information about coded character sets.

=item B<-csv>[=I<CSVFILE>]

Export information in as a CSV file, or import information if I<CSVFILE> is
specified.  When importing, the CSV file must be in exactly the same format
as the exported file.  The first row of the I<CSVFILE> must be the ExifTool
tag names (with optional group names) for each column of the file, and
values must be separated by commas.  A special "SourceFile" column specifies
the files associated with each row of information (a SourceFile of "*" may
be used to apply the information to all target images).  The following
examples demonstrate basic use of this option:

    # generate CSV file with common tags from all images in a directory
    exiftool -common -csv dir > out.csv

    # update metadata for all images in a directory from CSV file
    exiftool -csv=a.csv dir

Empty values are ignored when importing.  To force a tag to be deleted, use
the B<-f> option and set the value to "-" in the CSV file.  May be combined
with the B<-g> or B<-G> option to add group names to the tags.  Note that
list-type tags are stored as simple strings in a CSV file, but the B<-sep>
option may be used to split them back into separate items when importing.

Special feature:  B<-csv>+=I<CSVFILE> may be used to add items to existing
lists. This affects only list-type tags.  Also applies to the B<-j> option.

Note that this option is fundamentally different than all other output
format options because it requires information from all input files to be
buffered in memory before the output is written.  This may result in
excessive memory usage when processing a very large number of files with a
single command.

=item B<-d> I<FMT> (B<-dateFormat>)

Set the format for date/time tag values.  The specifics of the I<FMT> syntax
are system dependent -- consult the C<strftime> man page on your system for
details.  The default format is equivalent to "%Y:%m:%d %H:%M:%S".  This
option has no effect on date-only or time-only tags and ignores timezone
information if present.  Only one B<-d> option may be used per command.  The
inverse operation (ie. un-formatting a date/time value) is currently not
applied when writing a date/time tag.

=item B<-D> (B<-decimal>)

Show tag ID number in decimal when extracting information.

=item B<-E>, B<-ex> (B<-escapeHTML>, B<-escapeXML>)

Escape characters in output values for HTML (B<-E>) or XML (B<-ex>).  For
HTML, all characters with Unicode code points above U+007F are escaped as
well as the following 5 characters: & (&amp;) E<39> (&#39;) E<quot> (&quot;)
E<gt> (&gt;) and E<lt> (&lt;).  For XML, only these 5 characters are
escaped.  The B<-E> option is implied with B<-h>, and B<-ex> is implied with
B<-X>.  The inverse conversion is applied when writing tags.

=item B<-f> (B<-forcePrint>)

Force printing of tags even if their values are not found.  This option only
applies when tag names are specified.  With this option, a dash (C<->) is
printed for the value of any missing tag. May also be used to add a 'flags'
attribute to the B<-listx> output, or to allow tags to be deleted when
writing with the B<-csv>=I<CSVFILE> feature.

=item B<-g>[I<NUM>][:I<NUM>...] (B<-groupHeadings>)

Organize output by tag group.  I<NUM> specifies a group family number, and
may be 0 (general location), 1 (specific location), 2 (category), 3
(document number) or 4 (instance number).  Multiple families may be
specified by separating them with colons.  By default the resulting group
name is simplified by removing any leading C<Main:> and collapsing adjacent
identical group names, but this can be avoided by placing a colon before the
first family number (ie. B<-g:3:1>).  If I<NUM> is not specified, B<-g0> is
assumed.  Use the B<-listg> option to list group names for a specified
family.

=item B<-G>[I<NUM>][:I<NUM>...] (B<-groupNames>)

Same as B<-g> but print group name for each tag.

=item B<-h> (B<-htmlFormat>)

Use HTML table formatting for output.  Implies the B<-E> option.  The
formatting options B<-D>, B<-H>, B<-g>, B<-G>, B<-l> and B<-s> may be used
in combination with B<-h> to influence the HTML format.

=item B<-H> (B<-hex>)

Show tag ID number in hexadecimal when extracting information.

=item B<-htmlDump>[I<OFFSET>]

Generate a dynamic web page containing a hex dump of the EXIF information.
This can be a very powerful tool for low-level analysis of EXIF information.
The B<-htmlDump> option is also invoked if the B<-v> and B<-h> options are
used together.  The verbose level controls the maximum length of the blocks
dumped.  An I<OFFSET> may be given to specify the base for displayed
offsets.  If not provided, the EXIF/TIFF base offset is used.  Use
B<-htmlDump0> for absolute offsets.  Currently only EXIF/TIFF and JPEG
information is dumped, but the -u option can be used to give a raw hex dump
of other file formats.

=item B<-j>[=I<JSONFILE>] (B<-json>)

Use JSON (JavaScript Object Notation) formatting for console output, or
import JSON file if I<JSONFILE> is specified.  This option may be combined
with B<-g> to organize the output into objects by group, or B<-G> to add
group names to each tag.  List-type tags with multiple items are output as
JSON arrays unless B<-sep> is used.  By default XMP structures are flattened
into individual tags in the JSON output, but the original structure may be
preserved with the B<-struct> option (this also causes all list-type XMP
tags to be output as JSON arrays, otherwise single-item lists are output as
simple strings).  The B<-a> option is implied if the B<-g> or B<-G> options
are used, otherwise it is ignored and duplicate tags are suppressed.  The
B<-b>, B<-L> and B<-charset> options have no effect on the JSON output.

If I<JSONFILE> is specified, the file is imported and the tag definitions
from the file are used to set tag values on a per-file basis.  The special
"SourceFile" entry in each JSON object associates the information with a
specific target file (see the B<-csv> option for details).  The imported
JSON file must have the same format as the exported JSON files with the
exception that the B<-g> option is not compatible with the import file
format (use B<-G> instead).  Additionally, tag names in the input JSON file
may be suffixed with a C<#> to disable print conversion.

=item B<-l> (B<-long>)

Use long 2-line Canon-style output format.  Adds a description and
unconverted value to the XML output when B<-X> is used.

=item B<-L> (B<-latin>)

Use Windows Latin1 encoding (cp1252) for output tag values instead of the
default UTF-8.  When writing, B<-L> specifies that input text values are
Latin1 instead of UTF-8.  Equivalent to C<-charset latin>.

=item B<-lang> [I<LANG>]

Set current language for tag descriptions and converted values.  I<LANG> is
C<de>, C<fr>, C<ja>, etc.  Use B<-lang> with no other arguments to get a
list of available languages.  The default language is C<en> if B<-lang> is
not specified.  Note that tag/group names are always English, independent of
the B<-lang> setting, and translation of warning/error messages has not yet
been implemented.

By default, ExifTool uses UTF-8 encoding for special characters, but the
the B<-L> or B<-charset> option may be used to invoke other encodings.

Currently, the language support is not complete, but users are welcome to
help improve this by submitting their own translations.  To submit a set of
translations, first use the B<-listx> option and redirect the output to a
file to generate an XML tag database, then add entries for other languages,
zip this file, and email it to phil at owl.phy.queensu.ca for inclusion in
ExifTool.

=item B<-listItem> I<INDEX>

For list-type tags, this causes only the item with the specified index to be
extracted.  I<INDEX> is 0 for the first item in the list.  Has no effect
when writing or copying tags, in a B<-if> condition, or in combination with
structured output options.

=item B<-n> (B<--printConv>)

Read and write values as numbers instead of words.  By default, extracted
values are converted to a more human-readable format for printing, but the
B<-n> option disables this print conversion for all tags.  For example:

    > exiftool -Orientation -S a.jpg
    Orientation: Rotate 90 CW
    > exiftool -Orientation -S -n a.jpg
    Orientation: 6

The print conversion may also be disabled on a per-tag basis by suffixing
the tag name with a C<#> character:

    > exiftool -Orientation# -Orientation -S a.jpg
    Orientation: 6
    Orientation: Rotate 90 CW

These techniques may also be used to disable the inverse print conversion
when writing.  For example, the following commands all have the same effect:

    > exiftool -Orientation='Rotate 90 CW' a.jpg
    > exiftool -Orientation=6 -n a.jpg
    > exiftool -Orientation#=6 a.jpg

=item B<-p> I<FMTFILE> or I<STR> (B<-printFormat>)

Print output in the format specified by the given file or string (and ignore
other format options).  Tag names in the format file or string begin with a
C<$> symbol and may contain a leading group name and/or a trailing C<#>. 
Case is not significant.  Braces C<{}> may be used around the tag name to
separate it from subsequent text.  Use C<$$> to represent a C<$> symbol, and
C<$/> for a newline.  Multiple B<-p> options may be used, each contributing
a line of text to the output.  Lines beginning with C<#[HEAD]> and
C<#[TAIL]> are output only for the first and last processed files
respectively.  Lines beginning with C<#[BODY]> and lines not beginning with
C<#> are output for each processed file.  Other lines beginning with C<#>
are ignored.  For example, this format file:

    # this is a comment line
    #[HEAD]-- Generated by ExifTool $exifToolVersion --
    File: $FileName - $DateTimeOriginal
    (f/$Aperture, ${ShutterSpeed}s, ISO $EXIF:ISO)
    #[TAIL]-- end --

with this command:

    exiftool -p test.fmt a.jpg b.jpg

produces output like this:

    -- Generated by ExifTool 9.13 --
    File: a.jpg - 2003:10:31 15:44:19
    (f/5.6, 1/60s, ISO 100)
    File: b.jpg - 2006:05:23 11:57:38
    (f/8.0, 1/13s, ISO 100)
    -- end --

When B<-ee> (B<-extractEmbedded>) is combined with B<-p>, embedded documents
are effectively processed as separate input files.

If a specified tag does not exist, a minor warning is issued and the line
with the missing tag is not printed.  However, the B<-f> option may be used
to set the value of missing tags to '-', or the B<-m> option may be used to
ignore minor warnings and leave the missing values empty.

=item B<-php>

Format output as a PHP Array.  The B<-g>, B<-G>, B<-sep> and B<-struct>
options combine with B<-php> in the same way as with B<-json>.  As well, the
B<-b> option may be added to output binary data.  Here is a simple example
showing how this could be used in a PHP script:

    <?php
    eval('$array=' . `exiftool -php -q image.jpg`);
    print_r($array);
    ?>

=item B<-s>[I<NUM>] (B<-short>)

Short output format.  Prints tag names instead of descriptions.  Add I<NUM>
or up to 3 B<-s> options for even shorter formats:

    -s1 or -s        - print tag names instead of descriptions
    -s2 or -s -s     - no extra spaces to column-align values
    -s3 or -s -s -s  - print values only (no tag names)

Also effective when combined with B<-t>, B<-h>, B<-X> or B<-listx> options.

=item B<-S> (B<-veryShort>)

Very short format.  The same as B<-s2> (or two B<-s> options).  Tag names
are printed instead of descriptions, and no extra spaces are added to
column-align values.

=item B<-sep> I<STR> (B<-separator>)

Specify separator string for items in list-type tags.  When reading, the
default is to join list items with ", ".  When writing, this option causes
values assigned to list-type tags to be split into individual items at each
substring matching I<STR> (otherwise they are not split by default).  Space
characters in I<STR> match zero or more whitespace characters in the value.

=item B<-sort>

Sort output by tag description, or by tag name if the B<-s> option is used.
Tags are sorted within each group when combined with the B<-g> or B<-G>
option.  When sorting by description, the sort order will depend on the
B<-lang> option setting.  Without the B<-sort> option, tags appear in the
order they were specified on the command line, or if not specified, the
order they were extracted from the file.

=item B<-struct>, B<--struct>

Output structured XMP information instead of flattening to individual tags.
This option works well when combined with the XML (B<-X>) and JSON (B<-j>)
output formats.  For other output formats, the structures are serialized
into the same format as when writing structured information (see
L<http://owl.phy.queensu.ca/~phil/exiftool/struct.html> for details).  When
copying, structured tags are copied by default unless B<--struct> is used to
disable this feature (although flattened tags may still be copied by
specifying them individually unless B<-struct> is used).  These options have
no effect when assigning new values since both flattened and structured tags
may always be used when writing.

=item B<-t> (B<-tab>)

Output a tab-delimited list of description/values (useful for database
import).  May be combined with B<-s> to print tag names instead of
descriptions, or B<-S> to print tag values only, tab-delimited on a single
line.  The B<-t> option may also be used to add tag table information to the
B<-X> option output.

=item B<-T> (B<-table>)

Output tag values in table form.  Equivalent to B<-t -S -q -f>.

=item B<-v>[I<NUM>] (B<-verbose>)

Print verbose messages.  I<NUM> specifies the level of verbosity in the
range 0-5, with higher numbers being more verbose.  If I<NUM> is not given,
then each B<-v> option increases the level of verbosity by 1.  With any
level greater than 0, most other options are ignored and normal console
output is suppressed unless specific tags are extracted.  Using B<-v0>
causes the console output buffer to be flushed after each line (which may be
useful to avoid delays when piping exiftool output), and prints the name of
each processed file when writing.  Also see the B<-progress> option.

=item B<-w>[!] I<EXT> or I<FMT> (B<-textOut>)

Write console output to files with names ending in I<EXT>, one for each
source file.  The output file name is obtained by replacing the source file
extension (including the '.') with the specified extension (and a '.' is
added to the start of I<EXT> if it doesn't already contain one).
Alternatively, a I<FMT> string may be used to give more control over the
output file name and directory.  In the format string, %d, %f and %e
represent the directory, filename and extension of the source file, and %c
represents a copy number which is automatically incremented if the file
already exists.  %d includes the trailing '/' if necessary, but %e does not
include the leading '.'.  For example:

    -w %d%f.txt       # same effect as "-w txt"
    -w dir/%f_%e.out  # write files to "dir" as "FILE_EXT.out"
    -w dir2/%d%f.txt  # write to "dir2", keeping dir structure
    -w a%c.txt        # write to "a.txt" or "a1.txt" or "a2.txt"...

Existing files will not be overwritten unless an exclamation point is added
to the option name (ie. B<-w!> or B<-textOut!>).  Output directories are
created automatically if necessary.

Notes:

1) In a Windows BAT file the C<%> character is represented by C<%%>, so an
argument like C<%d%f.txt> is written as C<%%d%%f.txt>.

2) It is not possible to specify a simple filename as an argument for B<-w>.
Instead, this simple case is accomplished using shell redirection:

    exiftool FILE > out.txt

Advanced features:

A substring of the original file name, directory or extension may be taken
by specifying a field width immediately following the '%' character.  If the
width is negative, the substring is taken from the end.  The substring
position (characters to ignore at the start or end of the string) may be
given by a second optional value after a decimal point.  For example:

    Input File Name     Format Specifier    Output File Name
    ----------------    ----------------    ----------------
    Picture-123.jpg     %7f.txt             Picture.txt
    Picture-123.jpg     %-.4f.out           Picture.out
    Picture-123.jpg     %7f.%-3f            Picture.123
    Picture-123a.jpg    Meta%-3.1f.txt      Meta123.txt

For %d, the field width/position specifiers may be applied to the directory
levels instead of substring position by using a colon instead of a decimal
point in the format specifier.  For example:

    Source Dir     Format   Result       Notes
    ------------   ------   ----------   ------------------
    pics/2012/02   %2:d     pics/2012/   take top 2 levels
    pics/2012/02   %-:1d    pics/2012/   up one directory level
    pics/2012/02   %:1d     2012/02/     ignore top level
    pics/2012/02   %1:1d    2012/        take 1 level after top
    /Users/phil    %:2d     phil/        ignore top 2 levels

(Note that the root directory counts as one level when an absolute path is
used as in the last example above.)

For %c, these modifiers have a different effects.  If a field width is
given, the copy number is padded with zeros to the specified width.  A
leading '-' adds a dash before the copy number, and a '+' adds an underline.
By default, a copy number of zero is omitted, but this can be changed by
adding a decimal point to the modifier.  For example:

    -w A%-cZ.txt      # AZ.txt, A-1Z.txt, A-2Z.txt ...
    -w B%5c.txt       # B.txt, B00001.txt, B00002.txt ...
    -w C%.c.txt       # C0.txt, C1.txt, C2.txt ...
    -w D%-.c.txt      # D-0.txt, D-1.txt, D-2.txt ...
    -w E%-.4c.txt     # E-0000.txt, E-0001.txt, E-0002.txt ...
    -w F%-.4nc.txt    # F-0001.txt, F-0002.txt, F-0003.txt ...
    -w G%+c.txt       # G.txt, G_1.txt G_2.txt ...
    -w H%-lc.txt      # H.txt, H-b.txt, H-c.txt ...

A special feature allows the copy number to be incremented for each
processed file by using %C (upper case) instead of %c.  This allows a
sequential number to be added to output file names, even if the names are
different.  For %C, a copy number of zero is not omitted as it is with %c. 
The number before the decimal place gives the starting index, the number
after the decimal place gives the field width.  The following examples show
the output filenames when used with the command
C<exiftool rose.jpg star.jpg jet.jpg ...>:

    -w %C%f.txt       # 0rose.txt, 1star.txt, 2jet.txt
    -w %f-%10C.txt    # rose-10.txt, star-11.txt, jet-12.txt
    -w %.3C-%f.txt    # 000-rose.txt, 001-star.txt, 002-jet.txt
    -w %57.4C%f.txt   # 0057rose.txt, 0058star.txt, 0059jet.txt

All format codes may be modified by 'l' or 'u' to specify lower or upper
case respectively (ie. C<%le> for a lower case file extension).  When used
to modify %c or %C, the numbers are changed to an alphabetical base (see
example H above).  Also, %c may be modified by 'n' to count using natural
numbers starting from 1, instead of 0 (see example F above).

This same I<FMT> syntax is used with the B<-o> and B<-tagsFromFile> options,
although %c is only valid for output file names.

=item B<-X> (B<-xmlFormat>)

Use ExifTool-specific RDF/XML formatting for console output.  Implies the
B<-a> option, so duplicate tags are extracted.  The formatting options
B<-b>, B<-D>, B<-H>, B<-l>, B<-s>, B<-sep>, B<-struct> and B<-t> may be used
in combination with B<-X> to affect the output, but note that the tag ID
(B<-D>, B<-H> and B<-t>), binary data (B<-b>) and structured output
(B<-struct>) options are not effective for the short output (B<-s>). 
Another restriction of B<-s> is that only one tag with a given group and
name may appear in the output.  Note that the tag ID options (B<-D>, B<-H>
and B<-t>) will produce non-standard RDF/XML unless the B<-l> option is also
used.  By default, list-type tags with multiple values are formatted as an
RDF Bag, but they are combined into a single string when B<-s> or B<-sep> is
used.  Using B<-L> changes the XML encoding from "UTF-8" to "windows-1252". 
Other B<-charset> settings change the encoding only if there is a
corresponding standard XML character set.  The B<-b> option causes binary
data values to be written, encoded in base64 if necessary.  The B<-t> option
adds tag table information to the output (table C<name>, decimal tag C<id>,
and C<index> for cases where multiple conditional tags exist with the same
ID).

Note: This output is NOT the same as XMP because it uses
dynamically-generated property names corresponding to the ExifTool tag
names, and not the standard XMP properties.  To write XMP instead, use the
B<-o> option with an XMP extension for the output file.

=back

=head3 Processing control

=over 5

=item B<-a>, B<--a> (B<-duplicates>, B<--duplicates>)

Allow (B<-a>) or suppress (B<--a>) duplicate tag names to be extracted.  By
default, duplicate tags are suppressed unless the B<-ee> or B<-X> options
are used or the Duplicates option is enabled in the configuration file.

=item B<-e> (B<--composite>)

Extract existing tags only -- don't calculate composite tags.

=item B<-ee> (B<-extractEmbedded>)

Extract information from embedded documents in EPS and PDF files, embedded
MPF images in JPEG and MPO files, streaming metadata in AVCHD videos, and
the resource fork of Mac OS files.  Implies the B<-a> option.  Use B<-g3> or
B<-G3> to identify the originating document for extracted information.
Embedded documents containing sub-documents are indicated with dashes in the
family 3 group name.  (ie. C<Doc2-3> is the 3rd sub-document of the 2nd
embedded document.)

=item B<-ext> I<EXT>, B<--ext> I<EXT> (B<-extension>)

Process only files with (B<-ext>) or without (B<--ext>) a specified
extension.  There may be multiple B<-ext> and B<--ext> options.  Extensions
may begin with a leading '.', and case is not significant.  For example:

    exiftool -ext .JPG DIR            # process only JPG files
    exiftool --ext crw --ext dng DIR  # supported files but CRW/DNG
    exiftool --ext . DIR              # ignore if no extension
    exiftool -ext "*" DIR             # process all files
    exiftool -ext "*" --ext xml DIR   # process all but XML files

The extension may be C<"*"> as in the last two examples above to force
processing files with any extension (not just supported files).

Using this option has two main advantages over specifying C<*.I<EXT>> on the
command line:  1) It applies to files in subdirectories when combined with
the B<-r> option.  2) The B<-ext> option is case-insensitive, which is
useful when processing files on case-sensitive filesystems.

=item B<-F>[I<OFFSET>] (B<-fixBase>)

Fix the base for maker notes offsets.  A common problem with some image
editors is that offsets in the maker notes are not adjusted properly when
the file is modified.  This may cause the wrong values to be extracted for
some maker note entries when reading the edited file.  This option allows an
integer I<OFFSET> to be specified for adjusting the maker notes base offset.
If no I<OFFSET> is given, ExifTool takes its best guess at the correct base.
Note that exiftool will automatically fix the offsets for images which store
original offset information (ie. newer Canon models).  Offsets are fixed
permanently if B<-F> is used when writing EXIF to an image. ie)

    exiftool -F -exif:resolutionunit=inches image.jpg

=item B<-fast>[I<NUM>]

Increase speed of extracting information from JPEG images.  With this
option, ExifTool will not scan to the end of a JPEG image to check for an
AFCP or PreviewImage trailer, or past the first comment in GIF images or the
audio/video data in WAV/AVI files to search for additional metadata.  These
speed benefits are small when reading images directly from disk, but can be
substantial if piping images through a network connection.  For more
substantial speed benefits, B<-fast2> also causes exiftool to avoid
extracting any EXIF MakerNote information.

=item B<-fileOrder> [-]I<TAG>

Set file processing order according to the sorted value of the specified
I<TAG>.  For example, to process files in order of date:

    exiftool -fileOrder DateTimeOriginal DIR

Additional B<-fileOrder> options may be added for secondary sort keys. 
Floating point values are sorted numerically, and all other values are
sorted alphabetically.  The sort order may be reversed by prefixing the tag
name with a C<-> (ie. C<-fileOrder -createdate>).  A C<#> may be appended to
the tag name to disable print conversion for the sorted values.  Note that
the B<-fileOrder> option has a large performance impact since it involves an
additional processing pass of each file.

=item B<-i> I<DIR> (B<-ignore>)

Ignore specified directory name.  Use multiple B<-i> options to ignore more
than one directory name.  A special I<DIR> value of C<SYMLINKS> (case
sensitive) may be specified to ignore symbolic links when the B<-r> option
is used.

=item B<-if> I<EXPR>

Specify a condition to be evaluated before processing each I<FILE>.  I<EXPR>
is a Perl-like expression containing tag names prefixed by C<$> symbols.  It
is evaluated with the tags from each I<FILE> in turn, and the file is
processed only if the expression returns true.  Unlike Perl variable names,
tag names are not case sensitive and may contain a hyphen.  As well, tag
names may have a leading group name separated by a colon, and/or a trailing
C<#> character to disable print conversion.  The expression C<$GROUP:all>
evaluates to 1 if any tag exists in the specified C<GROUP>, or 0 otherwise
(see note 2 below).  When multiple B<-if> options are used, all conditions
must be satisfied to process the file.  Returns an exit status of 1 if all
files fail the condition.  Below are a few examples:

    # extract shutterspeed from all Canon images in a directory
    exiftool -shutterspeed -if '$make eq "Canon"' dir

    # add one hour to all images created on or after Apr. 2, 2006
    exiftool -alldates+=1 -if '$CreateDate ge "2006:04:02"' dir

    # set EXIF ISO value if possible, unless it is set already
    exiftool '-exif:iso<iso' -if 'not $exif:iso' dir

    # find images containing a specific keyword (case insensitive)
    exiftool -if '$keywords =~ /harvey/i' -filename dir

Notes:

1) The B<-n> and B<-b> options also apply to tags used in I<EXPR>.

2) Some binary data blocks are not extracted unless specified explicitly.
These tags are not available for use in the B<-if> condition unless they are
also specified on the command line.  The alternative is to use the
C<$GROUP:all> syntax. (ie. Use C<$exif:all> instead of C<$exif> in I<EXPR>
to test for the existence of EXIF tags.)

3) Tags in the string are interpolated the same way as with B<-p> before the
expression is evaluated.  In this interpolation, C<$/> is converted to a
newline and C<$$> represents a single C<$> symbol (so Perl variables, if
used, require a double C<$>).

=item B<-m> (B<-ignoreMinorErrors>)

Ignore minor errors and warnings.  This enables writing to files with minor
errors and disables some validation checks which could result in minor
warnings.  Generally, minor errors/warnings indicate a problem which usually
won't result in loss of metadata if ignored.  However, there are exceptions,
so ExifTool leaves it up to you to make the final decision.  Minor errors
and warnings are indicated by "[minor]" at the start of the message. 
Warnings which affect processing when ignored are indicated by "[Minor]"
(with a capital "M").

=item B<-o> I<OUTFILE> or I<FMT> (B<-out>)

Set the output file or directory name when writing information.  Without
this option, when any "real" tags are written the original file is renamed
to C<FILE_original> and output is written to I<FILE>.  When writing only
FileName and/or Directory "pseudo" tags, B<-o> causes the file to be copied
instead of moved, but directories specified for either of these tags take
precedence over that specified by the B<-o> option.

I<OUTFILE> may be C<-> to write to stdout.  The output file name may also be
specified using a I<FMT> string in which %d, %f and %e represent the
directory, file name and extension of I<FILE>.  Also, %c may be used to add
a copy number. See the B<-w> option for I<FMT> string examples.

The output file is taken to be a directory name if it already exists as a
directory or if the name ends with '/'.  Output directories are created if
necessary.  Existing files will not be overwritten.  Combining the
B<-overwrite_original> option with B<-o> causes the original source file to
be erased after the output file is successfully written.

A special feature of this option allows the creation of certain types of
files from scratch, or with the metadata from another type of file.  The
following file types may be created using this technique:

    XMP, ICC/ICM, MIE, VRD, EXIF

The output file type is determined by the extension of I<OUTFILE> (specified
as C<-.EXT> when writing to stdout).  The output file is then created from a
combination of information in I<FILE> (as if the B<-tagsFromFile> option was
used), and tag values assigned on the command line.  If no I<FILE> is
specified, the output file may be created from scratch using only tags
assigned on the command line.

=item B<-overwrite_original>

Overwrite the original I<FILE> (instead of preserving it by adding
C<_original> to the file name) when writing information to an image.
Caution: This option should only be used if you already have separate backup
copies of your image files.  The overwrite is implemented by renaming a
temporary file to replace the original.  This deletes the original file and
replaces it with the edited version in a single operation.  When combined
with B<-o>, this option causes the original file to be deleted if the output
file was successfully written.

=item B<-overwrite_original_in_place>

Similar to B<-overwrite_original> except that an extra step is added to
allow the original file attributes to be preserved.  For example, on a Mac
this causes the original file creation date, type, creator, label color,
icon and hard links to the file to be preserved (but note that the Mac OS
resource fork is always preserved unless specifically deleted with
C<-rsrc:all=>).  This is implemented by opening the original file in update
mode and replacing its data with a copy of a temporary file before deleting
the temporary.  The extra step results in slower performance, so the
B<-overwrite_original> option should be used instead unless necessary.

=item B<-P> (B<-preserve>)

Preserve the filesystem modification date/time of the original file
(C<FileModifyDate>) when writing.  Note that some filesystems store a
creation date which is not preserved by this option, with the exception of
Windows systems where Win32API::File::Time is available.  For other systems,
the B<-overwrite_original_in_place> option may be used if necessary to
preserve the creation date.

=item B<-password> I<PASSWD>

Specify password to allow processing of password-protected PDF documents. 
If a password is required but not given, a warning is issued and the
document is not processed.  Ignored if a password is not required.

=item B<-progress>

Show file progress count in messages.  The progress count appears in
brackets after then name of each processed file, and gives the current file
number and the total number of files to be processed.  Implies the B<-v0>
option, which prints the name of each processed file when writing.  When
combined with the [tt]-if[/tt] option, the total count includes all files
before the condition is applied.

=item B<-q> (B<-quiet>)

Quiet processing.  One B<-q> suppresses normal informational messages, and a
second B<-q> suppresses warnings as well.  Error messages can not be
suppressed, although minor errors may be downgraded to warnings with the
B<-m> option.

=item B<-r> (B<-recurse>)

Recursively process files in subdirectories.  Only meaningful if I<FILE> is
a directory name.  By default, exiftool will also follow symbolic links to
directories if supported by the system, but this may be disabled with
C<-i SYMLINKS> (see the B<-i> option for details).

=item B<-scanForXMP>

Scan all files (even unsupported formats) for XMP information unless found
already.  When combined with the B<-fast> option, only unsupported file
types are scanned.  Warning: It can be time consuming to scan large files.

=item B<-u> (B<-unknown>)

Extract values of unknown tags.  Add another B<-u> to also extract unknown
information from binary data blocks.  This option applies to tags with
numerical tag ID's, and causes tag names like "Exif_0xc5d9" to be generated
for unknown information.  It has no effect on information types which have
human-readable tag ID's (such as XMP), since unknown tags are extracted
automatically from these formats.

=item B<-U> (B<-unknown2>)

Extract values of unknown tags as well as unknown information from some
binary data blocks.  This is the same as two B<-u> options.

=item B<-z> (B<-zip>)

When reading, causes information to be extracted from .gz and .bz2
compressed images.  (Only one image per archive.  Requires gzip and bzip2 to
be installed on the system.)  When writing, causes compressed information to
be written if supported by the image format.  (ie. The PNG format supports
compressed text.)  This option also disables the recommended padding in
embedded XMP, saving 2424 bytes when writing XMP in a file.

=back

=head3 Special features

=over 5

=item B<-geotag> I<TRKFILE>

Geotag images from the specified GPS track log file.  Using the B<-geotag>
option is equivalent to writing a value to the C<Geotag> tag.  After the
B<-geotag> option has been specified, the value of the C<Geotime> tag is
written to define a date/time for the position interpolation.  If C<Geotime>
is not specified, the value is copied from C<DateTimeOriginal>.  For
example, the following two commands are equivalent:

    exiftool -geotag track.log image.jpg
    exiftool -geotag "-Geotime<DateTimeOriginal" image.jpg

When the C<Geotime> value is converted to UTC, the local system timezone is
assumed unless the date/time value contains a timezone.  Writing C<Geotime>
causes the following 8 EXIF tags to be created:  GPSLatitude,
GPSLatitudeRef, GPSLongitude, GPSLongitudeRef, GPSAltitude, GPSAltitudeRef,
GPSDateStamp and GPSTimeStamp.  Alternately C<XMP:Geotime> may be written to
create the following 5 XMP tags: GPSLatitude, GPSLongitude, GPSAltitude,
GPSAltitudeRef and GPSDateTime.

The C<Geosync> tag may be used to specify a time correction which is applied
to each C<Geotime> value for synchronization with GPS time.  For example,
the following command compensates for image times which are 1 minute and 20
seconds behind GPS:

    exiftool -geosync=+1:20 -geotag a.log DIR

C<Geosync> must be set before C<Geotime> (if specified) to be effective.
Advanced C<Geosync> features allow a linear time drift correction and
synchronization from previously geotagged images.  See "geotag.html" in the
full ExifTool distribution for more information.

Multiple B<-geotag> options may be used to concatinate GPS track log data.
Also, a single B<-geotag> option may be used to load multiple track log
files by using wildcards in the I<TRKFILE> name, but note that in this case
I<TRKFILE> must be quoted on most systems (with the notable exception of
Windows) to prevent filename expansion.  For example:

    exiftool -geotag "TRACKDIR/*.log" IMAGEDIR

Currently supported track file formats are GPX, NMEA RMC/GGA/GLL, KML, IGC,
Garmin XML and TCX, Magellan PMGNTRK, Honeywell PTNTHPR, and Winplus Beacon
text files.  See L</GEOTAGGING EXAMPLES> for examples.  Also see
"geotag.html" in the full ExifTool distribution and the
L<Image::ExifTool Options|Image::ExifTool/Options> for more details and for
information about geotag configuration options.

=item B<-globalTimeShift> I<SHIFT>

Shift all formatted date/time values by the specified amount when reading. 
Does not apply to unformatted (B<-n>) output.  I<SHIFT> takes the same form
as the date/time shift when writing (see
L<Image::ExifTool::Shift.pl|Image::ExifTool::Shift.pl> for details), with a
negative shift being indicated with a minus sign (C<->) at the start of the
I<SHIFT> string.  For example:

    # return all date/times, shifted back by 1 hour
    exiftool -globalTimeShift -1 -time:all a.jpg

    # set the file name from the shifted CreateDate (-1 day) for
    # all images in a directory
    exiftool "-filename<createdate" -globaltimeshift "-0:0:1 0:0:0" \
        -d %Y%m%d-%H%M%S.%%e dir

=item B<-use> I<MODULE>

Add features from specified plug-in I<MODULE>.  Currently, the MWG module is
the only plug-in module distributed with exiftool.  This module adds
read/write support for tags as recommended by the Metadata Working Group. 
To save typing, C<-use MWG> is assumed if the C<MWG> group is specified for
any tag on the command line.  See the
L<MWG Tags documentation|Image::ExifTool::TagNames/MWG Tags> for more
details.  (Note that this option is not reversible, and remains in effect
until the application terminates, even across the C<-execute> option.)

=back

=head3 Utilities

=over 5

=item B<-restore_original>

=item B<-delete_original>[!]

These utility options automate the maintenance of the C<_original> files
created by exiftool.  They have no effect on files without an C<_original>
copy.  The B<-restore_original> option restores the specified files from
their original copies by renaming the C<_original> files to replace the
edited versions.  For example, the following command restores the originals
of all JPG images in directory C<DIR>:

    exiftool -restore_original -ext jpg DIR

The B<-delete_original> option deletes the C<_original> copies of all files
specified on the command line.  Without a trailing C<!> this option prompts
for confirmation before continuing.  For example, the following command
deletes C<a.jpg_original> if it exists, after asking "Are you sure?":

    exiftool -delete_original a.jpg

These options may not be used with other options to read or write tag values
in the same command, but may be combined with options such B<-ext>, B<-if>,
B<-r>, B<-q> and B<-v>.

=back

=head3 Other options

=over 5

=item B<-@> I<ARGFILE>

Read command-line arguments from the specified file.  The file contains one
argument per line (NOT one option per line -- some options require
additional arguments, and all arguments must be placed on separate lines).
Blank lines and lines beginning with C<#> and are ignored.  Normal shell
processing of arguments is not performed, which among other things means
that arguments should not be quoted and spaces are treated as any other
character.  I<ARGFILE> may exist relative to either the current directory or
the exiftool directory unless an absolute pathname is given.

For example, the following I<ARGFILE> will set the value of Copyright to
"Copyright YYYY, Phil Harvey", where "YYYY" is the year of CreateDate:

    -d
    %Y
    -copyright<Copyright $createdate, Phil Harvey

=item B<-k> (B<-pause>)

Pause with the message C<-- press any key --> or C<-- press RETURN -->
(depending on your system) before terminating.  This option is used to
prevent the command window from closing when run as a Windows drag and drop
application.

=item B<-list>, B<-listw>, B<-listf>, B<-listr>, B<-listwf>,
B<-listg>[I<NUM>], B<-listd>, B<-listx>

Print a list of all valid tag names (B<-list>), all writable tag names
(B<-listw>), all supported file extensions (B<-listff>), all recognized file
extensions (B<-listr>), all writable file extensions (B<-listwf>), all tag
groups [in a specified family] (B<-listg>[I<NUM>]), all deletable tag groups
(B<-listd>), or an XML database of tag details including language
translations (B<-listx>).  The B<-list>, B<-listw> and B<-listx> options may
be followed by an additional argument of the form C<-GROUP:All> to list only
tags in a specific group, where C<GROUP> is one or more family 0-2 group
names (excepting EXIF IFD groups) separated by colons.  With B<-listg>,
I<NUM> may be given to specify the group family, otherwise family 0 is
assumed.  Here are some examples:

    -list               # list all tag names
    -list -EXIF:All     # list all EXIF tags
    -list -xmp:time:all # list all XMP tags relating to time
    -listw -XMP-dc:All  # list all writable XMP-dc tags
    -listf              # list all supported file extensions
    -listr              # list all recognized file extensions
    -listwf             # list all writable file extensions
    -listg1             # list all groups in family 1
    -listd              # list all deletable groups
    -listx -EXIF:All    # list database of EXIF tags in XML format
    -listx -XMP:All -s  # list short XML database of XMP tags

When combined with B<-listx>, the B<-s> option shortens the output by
omitting the descriptions and values (as in the last example above), and
B<-f> adds a 'flags' attribute if applicable.  The flags are formatted as a
comma-separated list of the following possible values:  Avoid, Binary, List,
Mandatory, Permanent, Protected, Unknown and Unsafe (see the L<Tag Name
documentation|Image::ExifTool::TagNames>).  For XMP List tags, the list type
(Alt, Bag or Seq) is added to the flags, and flattened structure tags are
indicated by a Flattened flag.

Note that none of the B<-list> options require an input I<FILE>.

=item B<-ver>

Print exiftool version number.

=back

=head3 Advanced options

Among other things, the advanced options allow complex processing to be
performed from a single command without the need for additional scripting.
This may be particularly useful for implementations such as Windows
drag-and-drop applications.  These options may also be used to improve
performance in multi-pass processing by reducing the overhead required to
load exiftool for each invocation.

=over 5

=item B<-common_args>

Specifies that all arguments following this option are common to all
executed commands when B<-execute> is used.  This and the B<-config> option
are the only options that may not be used inside a B<-@> I<ARGFILE>.  Note
that by definition this option and its arguments MUST come after all other
options on the command line.

=item B<-config> I<CFGFILE>

Load specified configuration file instead of the default ".ExifTool_config".
If used, this option must come before all other arguments on the command
line.  The I<CFGFILE> name may contain a directory specification (otherwise
the file must exist in the current directory), or may be set to an empty
string ("") to disable loading of the config file.  See the sample
configuration file and "config.html" in the full ExifTool distribution for
more information about the ExifTool configuration file.

=item B<-echo>[2] I<TEXT>

Echo text to stdout (B<-echo>) or stderr (B<-echo2>).  Text is output as
the command line is parsed, before the processing of any input files.

=item B<-execute>[I<NUM>]

Execute command for all arguments up to this point on the command line.
Allows multiple commands to be executed from a single command line.  I<NUM>
is an optional number that is echoed in the "{ready}" message when using the
B<-stay_open> feature.

=item B<-srcfile> I<FMT>

Specify a different source file to be processed based on the name of the
original I<FILE>.  This may be useful in some special situations for
processing related preview images or sidecar files.  See the B<-w> option
for a description of the I<FMT> syntax.  Note that file name I<FMT> strings
for all options are based on the original I<FILE> specified from the command
line, not the name of the source file specified by B<-srcfile>.  A I<FMT> of
C<@> may be used to represent the original I<FILE>, and may be useful when
specifying multiple B<-srcfile> options (ie. to fall back to processing the
original I<FILE> if no sidecar exists).

If than one B<-srcfile> option is specified, the files are tested in order
and the first existing source file is processed.  If none of the source
files already exist, then exiftool uses the first B<-srcfile> specified.

=item B<-stay_open> I<FLAG>

If I<FLAG> is C<1> or C<True>, causes exiftool keep reading from the B<-@>
I<ARGFILE> even after reaching the end of file.  This feature allows calling
applications to pre-load exiftool, thus avoiding the overhead of loading
exiftool for each command.  The procedure is as follows:

1) Execute C<exiftool -stay_open True -@ I<ARGFILE>>, where I<ARGFILE> is the
name of an existing (possibly empty) argument file or C<-> to pipe arguments
from the standard input.

2) Write exiftool command-line arguments to I<ARGFILE>, one argument per
line (see the B<-@> option for details).

3) Write C<-execute\n> to I<ARGFILE>, where C<\n> represents a newline
sequence.  (Note: You may need to flush your write buffers here if using
buffered output.)  Exiftool will then execute the command with the arguments
received up to this point, send a "{ready}" message to stdout when done
(unless the B<-q> option is used), and continue trying to read arguments for
the next command from I<ARGFILE>.  To aid in command/response
synchronization, any number appended to the C<-execute> option is echoed in
the "{ready}" message.  For example, C<-execute613> results in "{ready613}".

4) Repeat steps 2 and 3 for each command.

5) Write C<-stay_open\nFalse\n> to I<ARGFILE> when done.  This will cause
exiftool to process any remaining command-line arguments then exit normally.

The input I<ARGFILE> may be changed at any time before step 5 above by
writing the following lines to the currently open I<ARGFILE>:

    -stay_open
    True
    -@
    NEWARGFILE

This causes I<ARGFILE> to be closed, and I<NEWARGFILE> to be kept open.
(Without the B<-stay_open> here, exiftool would have returned to reading
arguments from I<ARGFILE> after reaching the end of I<NEWARGFILE>.)

Note:  When writing arguments to a disk file there is a delay of up to 0.01
seconds after writing C<-execute\n> before exiftool starts processing the
command.  This delay may be avoided by sending a CONT signal to the exiftool
process immediately after writing C<-execute\n>.  (There is no associated
delay when writing arguments via a pipe with C<-@ ->, so the signal is not
necessary when using this technique.)

=back

=head1 READING EXAMPLES

B<Note>: Beware when cutting and pasting these examples into your terminal!
Some characters such as single and double quotes and hyphens may have been
changed into similar-looking yet functionally-different characters by the
text formatter used to display this documentation.  Also note that Windows
users must use double quotes instead of single quotes as below around
arguments containing special characters.

=over 5

=item exiftool -a -u -g1 a.jpg

Print all meta information in an image, including duplicate and unknown
tags, sorted by group (for family 1).

=item exiftool -common dir

Print common meta information for all images in C<dir>.

=item exiftool -T -createdate -aperture -shutterspeed -iso dir > out.txt

List specified meta information in tab-delimited column form for all images
in C<dir> to an output text file named "out.txt".

=item exiftool -s -ImageSize -ExposureTime b.jpg

Print ImageSize and ExposureTime tag names and values.

=item exiftool -l -canon c.jpg d.jpg

Print standard Canon information from two image files.

=item exiftool -r -w .txt -common pictures

Recursively extract common meta information from files in C<pictures>
directory, writing text output to C<.txt> files with the same names.

=item exiftool -b -ThumbnailImage image.jpg > thumbnail.jpg

Save thumbnail image from C<image.jpg> to a file called C<thumbnail.jpg>.

=item exiftool -b -JpgFromRaw -w _JFR.JPG -ext CRW -r .

Recursively extract JPG image from all Canon CRW files in the current
directory, adding C<_JFR.JPG> for the name of the output JPG files.

=item exiftool -d '%r %a, %B %e, %Y' -DateTimeOriginal -S -s *.jpg

Print formatted date/time for all JPG files in the current directory.

=item exiftool -IFD1:XResolution -IFD1:YResolution image.jpg

Extract image resolution from EXIF IFD1 information (thumbnail image IFD).

=item exiftool '-*resolution*' image.jpg

Extract all tags with names containing the word "Resolution" from an image.

=item exiftool -xmp:author:all -a image.jpg

Extract all author-related XMP information from an image.

=item exiftool -xmp -b a.jpg > out.xmp

Extract complete XMP data record intact from C<a.jpg> and write it to
C<out.xmp> using the special C<XMP> tag (see the Extra tags in
L<Image::ExifTool::TagNames|Image::ExifTool::TagNames>).

=item exiftool -p '$filename has date $dateTimeOriginal' -q -f dir

Print one line of output containing the file name and DateTimeOriginal for
each image in directory C<dir>.

=item exiftool -ee -p '$gpslatitude, $gpslongitude, $gpstimestamp' a.m2ts

Extract all GPS positions from an AVCHD video.

=item exiftool -icc_profile -b -w icc image.jpg

Save complete ICC_Profile from an image to an output file with the same name
and an extension of C<.icc>.

=item exiftool -htmldump -w tmp/%f_%e.html t/images

Generate HTML pages from a hex dump of EXIF information in all images from
the C<t/images> directory.  The output HTML files are written to the C<tmp>
directory (which is created if it didn't exist), with names of the form
'FILENAME_EXT.html'.

=back

=head1 WRITING EXAMPLES

Note that quotes are necessary around arguments which contain certain
special characters such as C<E<gt>>, C<E<lt>> or any white space.  These
quoting techniques are shell dependent, but the examples below will work for
most Unix shells.  With the Windows cmd shell however, double quotes should
be used (ie. -Comment=E<34>This is a new commentE<34>).

=over 5

=item exiftool -Comment='This is a new comment' dst.jpg

Write new comment to a JPG image (replaces any existing comment).

=item exiftool -comment= -o newdir *.jpg

Remove comment from all JPG images in the current directory, writing the
modified images to a new directory.

=item exiftool -keywords=EXIF -keywords=editor dst.jpg

Replace existing keyword list with two new keywords (C<EXIF> and C<editor>).

=item exiftool -Keywords+=word -o newfile.jpg src.jpg

Copy a source image to a new file, and add a keyword (C<word>) to the
current list of keywords.

=item exiftool -exposurecompensation+=-0.5 a.jpg

Decrement the value of ExposureCompensation by 0.5 EV.  Note that += with a
negative value is used for decrementing because the -= operator is used for
conditional deletion (see next example).

=item exiftool -credit-=xxx dir

Delete Credit information from all files in a directory where the Credit
value was (C<xxx>).

=item exiftool -xmp:description-de='k&uuml;hl' -E dst.jpg

Write alternate language for XMP:Description, using HTML character escaping
to input special characters.

=item exiftool -all= dst.jpg

Delete all meta information from an image.  Note: You should NOT do this to
RAW images (except DNG) since proprietary RAW image formats often contain
information in the makernotes that is necessary for converting the image.

=item exiftool -all= -comment='lonely' dst.jpg

Delete all meta information from an image and add a comment back in.  (Note
that the order is important: C<-comment='lonely' -all=> would also delete
the new comment.)

=item exiftool -all= --jfif:all dst.jpg

Delete all meta information except JFIF group from an image.

=item exiftool -Photoshop:All= dst.jpg

Delete Photoshop meta information from an image (note that the Photoshop
information also includes IPTC).

=item exiftool -r -XMP-crss:all= DIR

Recursively delete all XMP-crss information from images in a directory.

=item exiftool '-ThumbnailImageE<lt>=thumb.jpg' dst.jpg

Set the thumbnail image from specified file (Note: The quotes are necessary
to prevent shell redirection).

=item exiftool '-JpgFromRawE<lt>=%d%f_JFR.JPG' -ext CRW -r .

Recursively write JPEG images with filenames ending in C<_JFR.JPG> to the
JpgFromRaw tag of like-named files with extension C<.CRW> in the current
directory.  (This is the inverse of the C<-JpgFromRaw> command of the
L</READING EXAMPLES> section above.)

=item exiftool -DateTimeOriginal-='0:0:0 1:30:0' dir

Adjust original date/time of all images in directory C<dir> by subtracting
one hour and 30 minutes.  (This is equivalent to C<-DateTimeOriginal-=1.5>.
See L<Image::ExifTool::Shift.pl|Image::ExifTool::Shift.pl> for details.)

=item exiftool -createdate+=3 -modifydate+=3 a.jpg b.jpg

Add 3 hours to the CreateDate and ModifyDate timestamps of two images.

=item exiftool -AllDates+=1:30 -if '$make eq E<34>CanonE<34>' dir

Shift the values of DateTimeOriginal, CreateDate and ModifyDate forward by 1
hour and 30 minutes for all Canon images in a directory.  (The AllDates tag
is provided as a shortcut for these three tags, allowing them to be accessed
via a single tag.)

=item exiftool -xmp:city=Kingston image1.jpg image2.nef

Write a tag to the XMP group of two images.  (Without the C<xmp:> this tag
would get written to the IPTC group since C<City> exists in both, and IPTC
is preferred by default.)

=item exiftool -LightSource-='Unknown (0)' dst.tiff

Delete C<LightSource> tag only if it is unknown with a value of 0.

=item exiftool -whitebalance-=auto -WhiteBalance=tung dst.jpg

Set C<WhiteBalance> to C<Tungsten> only if it was previously C<Auto>.

=item exiftool -comment-= -comment='new comment' a.jpg

Write a new comment only if the image doesn't have one already.

=item exiftool -o %d%f.xmp dir

Create XMP meta information data files for all images in C<dir>.

=item exiftool -o test.xmp -owner=Phil -title='XMP File'

Create an XMP data file only from tags defined on the command line.

=item exiftool '-ICC_Profile<=%d%f.icc' image.jpg

Write ICC_Profile to an image from a C<.icc> file of the same name.

=item exiftool -hierarchicalkeywords='{keyword=one,children={keyword=B}}'

Write structured XMP information.

=item exiftool -trailer:all= image.jpg

Delete any trailer found after the end of image (EOI) in a JPEG file.  A
number of digital cameras store a large PreviewImage after the JPEG EOI, and
the file size may be reduced significantly by deleting this trailer.  See
the L<JPEG Tags documentation|Image::ExifTool::TagNames/JPEG Tags> for a
list of recognized JPEG trailers.

=back

=head1 COPYING EXAMPLES

These examples demonstrate the ability to copy tag values between files.

=over 5

=item exiftool -tagsFromFile src.crw dst.jpg

Copy the values of all writable tags from C<src.crw> to C<dst.jpg>, writing
the information to same-named tags in the preferred groups.

=item exiftool -TagsFromFile src.jpg -all:all dst.jpg

Copy the values of all writable tags from C<src.jpg> to C<dst.jpg>,
preserving the original tag groups.

=item exiftool -all= -tagsfromfile src.jpg -exif:all dst.jpg

Erase all meta information from C<dst.jpg> image, then copy EXIF tags from
C<src.jpg>.

=item exiftool -exif:all= -tagsfromfile @ -all:all -unsafe bad.jpg

Rebuild all EXIF meta information from scratch in an image.  This technique
can be used in JPEG images to repair corrupted EXIF information which
otherwise could not be written due to errors.  The C<Unsafe> tag is a
shortcut for unsafe EXIF tags in JPEG images which are not normally copied. 
See the L<tag name documentation|Image::ExifTool::TagNames> for more details
about unsafe tags.

=item exiftool -Tagsfromfile a.jpg out.xmp

Copy meta information from C<a.jpg> to an XMP data file.  If the XMP data
file C<out.xmp> already exists, it will be updated with the new information.
Otherwise the XMP data file will be created.  Only XMP, ICC and MIE files
may be created like this (other file types may be edited but not created).
See L</WRITING EXAMPLES> above for another technique to generate XMP files.

=item exiftool -tagsFromFile a.jpg -XMP:All= -ThumbnailImage= -m b.jpg

Copy all meta information from C<a.jpg> to C<b.jpg>, deleting all XMP
information and the thumbnail image from the destination.

=item exiftool -TagsFromFile src.jpg -title -author=Phil dst.jpg

Copy title from one image to another and set a new author name.

=item exiftool -TagsFromFile a.jpg -ISO -TagsFromFile b.jpg -comment
dst.jpg

Copy ISO from one image and Comment from another image to a destination
image.

=item exiftool -tagsfromfile src.jpg -exif:all --subifd:all dst.jpg

Copy only the EXIF information from one image to another, excluding SubIFD
tags.

=item exiftool '-DateTimeOriginal>FileModifyDate' dir

Use the original date from the meta information to set the same file's
filesystem modification date for all images in a directory.  (Note that
C<-TagsFromFile @> is assumed if no other B<-TagsFromFile> is specified when
redirecting information as in this example.)

=item exiftool -TagsFromFile src.jpg '-all>xmp:all' dst.jpg

Copy all possible information from C<src.jpg> and write in XMP format to
C<dst.jpg>.

=item exiftool -@ iptc2xmp.args -iptc:all= a.jpg

Translate IPTC information to XMP with appropriate tag name conversions, and
delete the original IPTC information from an image.  This example uses
iptc2xmp.args, which is a file included with the ExifTool distribution that
contains the required arguments to convert IPTC information to XMP format.
Also included with the distribution are xmp2iptc.args (which performs the
inverse conversion) and a few more .args files for other conversions between
EXIF, IPTC and XMP.

=item exiftool -tagsfromfile %d%f.CRW -r -ext JPG dir

Recursively rewrite all C<JPG> images in C<dir> with information copied from
the corresponding C<CRW> images in the same directories.

=item exiftool '-make+>keywords' image.jpg

Add camera make to list of keywords.

=item exiftool '-comment<ISO=$exif:iso Exposure=${shutterspeed}' dir

Set the Comment tag of all images in C<dir> from the values of the EXIF:ISO
and ShutterSpeed tags.  The resulting comment will be in the form "ISO=100
Exposure=1/60".

=item exiftool -TagsFromFile src.jpg -icc_profile dst.jpg

Copy ICC_Profile from one image to another.

=item exiftool -TagsFromFile src.jpg -all:all dst.mie

Copy all meta information in its original form from a JPEG image to a MIE
file.  The MIE file will be created if it doesn't exist.  This technique can
be used to store the metadata of an image so it can be inserted back into
the image (with the inverse command) later in a workflow.

=item exiftool -o dst.mie -all:all src.jpg

This command performs exactly the same task as the command above, except
that the B<-o> option will not write to an output file that already exists.

=item exiftool -XMP:Flash="{mode=on,fired=true,return=not}" a.jpg

Write a structured tag.  See
L<http://owl.phy.queensu.ca/~phil/exiftool/struct.html> for more details.

=item exiftool -if '$jpgfromraw' -b -jpgfromraw -w %d%f_%ue.jpg -execute
-if '$previewimage' -b -previewimage -w %d%f_%ue.jpg -execute
-tagsfromfile @ -srcfile %d%f_%ue.jpg -overwrite_original
-common_args --ext jpg DIR

[Advanced] Extract JpgFromRaw or PreviewImage from all but JPG files in DIR,
saving them with file names like C<image_EXT.jpg>, then add all meta
information from the original files to the extracted images.  Here, the
command line is broken into three sections (separated by B<-execute>
options), and each is executed as if it were a separate command.  The
B<-common_args> option causes the C<--ext jpg DIR> arguments to be applied
to all three commands, and the B<-srcfile> option allows the extracted JPG
image to be the source file for the third command (whereas the RAW files are
the source files for the other two commands).

=back

=head1 RENAMING EXAMPLES

By writing the C<FileName> and C<Directory> tags, files are renamed and/or
moved to new directories.  This can be particularly useful and powerful for
organizing files by date when combined with the B<-d> option.  New
directories are created as necessary, but existing files will not be
overwritten.  The format codes %d, %f and %e may be used in the new file
name to represent the directory, name and extension of the original file,
and %c may be used to add a copy number if the file already exists (see the
B<-w> option for details).  Note that if used within a date format string,
an extra '%' must be added to pass these codes through the date/time parser.
(And further note that in a Windows batch file, all '%' characters must also
be escaped, so in this extreme case '%%%%f' is necessary to pass a simple
'%f' through the two levels of parsing.)  See
L<http://owl.phy.queensu.ca/~phil/exiftool/filename.html> for additional
documentation and examples.

=over 5

=item exiftool -filename=new.jpg dir/old.jpg

Rename C<old.jpg> to C<new.jpg> in directory C<dir>.

=item exiftool -directory=%e dir

Move all files from directory C<dir> into directories named by the original
file extensions.

=item exiftool '-Directory<DateTimeOriginal' -d %Y/%m/%d dir

Move all files in C<dir> into a directory hierarchy based on year, month and
day of C<DateTimeOriginal>.  ie) This command would move the file
C<dir/image.jpg> with a C<DateTimeOriginal> of C<2005:10:12 16:05:56> to
C<2005/10/12/image.jpg>.

=item exiftool -o . '-Directory<DateTimeOriginal' -d %Y/%m/%d dir

Same effect as above except files are copied instead of moved.

=item exiftool '-filename<%f_${focallength}.%e' dir

Rename all files in C<dir> by adding FocalLength to the file name.

=item exiftool '-FileName<CreateDate' -d %Y%m%d_%H%M%S%%-c.%%e dir

Rename all images in C<dir> according to the C<CreateDate> date and time,
adding a copy number with leading '-' if the file already exists (C<%-c>),
and preserving the original file extension (C<%e>).  Note the extra '%'
necessary to escape the filename codes (C<%c> and C<%e>) in the date format
string.

=item exiftool -r '-FileName<CreateDate' -d %Y-%m-%d/%H%M_%%f.%%e dir

Both the directory and the filename may be changed together via the
C<FileName> tag if the new C<FileName> contains a '/'.  The example above
recursively renames all images in a directory by adding a C<CreateDate>
timestamp to the start of the filename, then moves them into new directories
named by date.

=item exiftool '-FileName<${CreateDate}_$filenumber.jpg' -d %Y%m%d *.jpg

Set the filename of all JPG images in the current directory from the
CreateDate and FileNumber tags, in the form "20060507_118-1861.jpg".

=back

=head1 GEOTAGGING EXAMPLES

ExifTool implements geotagging via 3 special tags: Geotag (which for
convenience is also implemented as an exiftool option), Geosync and Geotime.
The examples below highlight some geotagging features.  See
L<http://owl.phy.queensu.ca/~phil/exiftool/geotag.html> for additional
documentation.

=over 5

=item exiftool -geotag track.log a.jpg

Geotag an image (C<a.jpg>) from position information in a GPS track log
(C<track.log>).  Since the C<Geotime> tag is not specified, the value of
DateTimeOriginal is used for geotagging.  Local system time is assumed
unless DateTimeOriginal contains a timezone.

=item exiftool -geotag t.log -geotime='2009:04:02 13:41:12-05:00' a.jpg

Geotag an image with the GPS position for a specific time.  (Note that the
C<Geotag> tag must be assigned before C<Geotime> for the GPS data to be
available when C<Geotime> is set.)

=item exiftool -geotag log.gpx '-xmp:geotimeE<lt>createdate' dir

Geotag all images in directory C<dir> with XMP tags instead of EXIF tags,
based on the image CreateDate.  (In this case, the order of the arguments
doesn't matter because tags with values copied from other tags are always
set after constant values.)

=item exiftool -geotag a.log -geosync=-20 dir

Geotag images in directory C<dir>, accounting for image timestamps which
were 20 seconds ahead of GPS.

=item exiftool -geotag a.log -geosync=1.jpg -geosync=2.jpg dir

Geotag images using time synchronization from two previously geotagged images
(1.jpg and 2.jpg), synchronizing the image and GPS times using a linear time
drift correction.

=item exiftool -geotag a.log '-geotimeE<lt>${createdate}+01:00' dir

Geotag images in C<dir> using CreateDate with the specified timezone.  If
CreateDate already contained a timezone, then the timezone specified on the
command line is ignored.

=item exiftool -geotag= a.jpg

Delete GPS tags which may have been added by the geotag feature.  Note that
this does not remove all GPS tags -- to do this instead use C<-gps:all=>.

=item exiftool -xmp:geotag= a.jpg

Delete XMP GPS tags which were added by the geotag feature.

=item exiftool -xmp:geotag=track.log a.jpg

Geotag an image with XMP tags, using the time from DateTimeOriginal.

=item exiftool -geotag a.log -geotag b.log -r dir

Combine multiple track logs and geotag an entire directory tree of images.

=item exiftool -geotag 'tracks/*.log' -r dir

Read all track logs from the C<tracks> directory.

=item exiftool -p gpx.fmt -d %Y-%m-%dT%H:%M:%SZ dir > out.gpx

Generate a GPX track log from all images in directory C<dir>.  This example
uses the C<gpx.fmt> file included in the full ExifTool distribution package
and assumes that the images in C<dir> have all been previously geotagged.

=back

=head1 PIPING EXAMPLES

=over 5

=item cat a.jpg | exiftool -

Extract information from stdin.

=item exiftool image.jpg -thumbnailimage -b | exiftool -

Extract information from an embedded thumbnail image.

=item cat a.jpg | exiftool -iptc:keywords+=fantastic - > b.jpg

Add an IPTC keyword in a pipeline, saving output to a new file.

=item wget -qO - http://a.domain.com/bigfile.jpg | exiftool -fast -

Extract information from an image over the internet using the GNU wget
utility.  The B<-fast> option prevents exiftool from scanning for trailer
information, so only the meta information header is transferred.

=item exiftool a.jpg -thumbnailimage -b | exiftool -comment=wow - |
exiftool a.jpg -thumbnailimage'<=-'

Add a comment to an embedded thumbnail image.  (Why anyone would want to do
this I don't know, but I've included this as an example to illustrate the
flexibility of ExifTool.)

=back

=head1 DIAGNOSTICS

The exiftool application exits with a status of 0 on success, or 1 if an
error occured or if all files failed the B<-if> condition.

=head1 AUTHOR

Copyright 2003-2013, Phil Harvey

This is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.

=head1 SEE ALSO

L<Image::ExifTool(3pm)|Image::ExifTool>,
L<Image::ExifTool::TagNames(3pm)|Image::ExifTool::TagNames>,
L<Image::ExifTool::Shortcuts(3pm)|Image::ExifTool::Shortcuts>,
L<Image::ExifTool::Shift.pl|Image::ExifTool::Shift.pl>

=cut

#------------------------------------------------------------------------------
# end
